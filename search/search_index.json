{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Uvod","text":"<p>MMST Web development React radionica je namijenjena svim osobama koje imaju odre\u0111eno predznanje u izradi web stranica, a \u017eele da se upoznaju sa kreiranjem dinami\u010dkih i stranica s React.js bibliotekom.</p> <p>U zadnjih dvadesetak godina Web stranice su jedan od glavnih na\u010dina digitalne komunikacije. Za razliku od standardnih medija, Web nudi mogu\u0107nost objave sadr\u017eaja i to na jednostavan na\u010din.</p> <p>Preporu\u010deno prethodno znanje za ovu radionicu su razumijevanje:</p> <ul> <li>\u0160ta je internet pretra\u017eiva\u010d</li> <li>Kori\u0161tenje pretra\u017eiva\u010da</li> <li>Poznavanje osnova rada na ra\u010dunaru (kreiranje, izmjene i brisanje datoteka)</li> <li>Poznavanje HTML, CSS i JavaScript</li> </ul> <p>Kroz ovu radionicu \u0107ete nau\u010diti kori\u0161tenje raznih alata i opcija za kreiranje i ure\u0111ivanje web stranica, kao i njihovih elemenata na moderan na\u010din, pored \u010dega \u0107ete imati priliku nau\u010diti pisati uredan, jednostavan kod.</p>"},{"location":"#bhff-mobile-makerspace-team","title":"BHFF Mobile Makerspace Team","text":"<p>MMST tim je jedan od mnogih timova unutar BHFF-a. Primarno smo zadu\u017eeni za dvije stvari:</p> <ul> <li>Preno\u0161enje direktnog tehni\u010dkog znanja sa BHFF scholara na studente i \u0161kolarce \u0161irom Bosne i Hercegovine</li> <li>Primarni outreach fondacije gdje se kroz na\u0161e radionice novi ljudi upoznavaju sa benefitima fondacije</li> </ul>"},{"location":"content/data-manipulation/","title":"React Data Manipulation: Upravljanje Podacima u React Aplikacijama","text":"<p>Sadr\u017eaj</p> <ol> <li>Uvod: Za\u0161to upravljanje podacima?</li> <li>Vrste i izvori podataka u Reactu</li> <li>Osnovni koncepti manipulacije podacima</li> <li>Kori\u0161tenje lokalnog stanja (useState)</li> <li>Props: prijenos podataka me\u0111u komponentama</li> <li>Podizanje state-a (\"Lifting State Up\")</li> <li>Globalno stanje i Context API</li> <li>Napredne biblioteke za upravljanje stanjem</li> <li>Dohva\u0107anje podataka s API-ja i serverska komunikacija</li> <li>Transformacija, filtriranje i prikaz podataka</li> <li>Rad sa listama i klju\u010devima</li> <li>Optimizacija performansi</li> <li>Forme: upravljanje unosom i validacija</li> <li>Nekontrolirane komponente i rad s ref-ovima</li> <li>Ke\u0161iranje i lokalna pohrana</li> <li>Naj\u010de\u0161\u0107e gre\u0161ke i dobre prakse</li> <li>Napredne teme i korisni alati</li> <li>Dodatni resursi</li> </ol>"},{"location":"content/data-manipulation/#1-uvod-zasto-upravljanje-podacima","title":"1. Uvod: Za\u0161to upravljanje podacima?","text":"<p>Upravljanje podacima je temelj svake ozbiljne React aplikacije. Bez jasnog plana kako \u0107ete dohvatiti, transformirati, dijeliti i prikazivati podatke, aplikacija brzo postaje neodr\u017eiva, spora i puna bugova. Dobar sistem za data manipulation donosi:</p> <ul> <li>Predvidljivo pona\u0161anje aplikacije (nema iznenadnih gre\u0161aka ili nelogi\u010dnosti)</li> <li>Lak\u0161e odr\u017eavanje i skaliranje koda</li> <li>Bolje korisni\u010dko iskustvo (br\u017ei UI, manje bugova)</li> <li>Ve\u0107u fleksibilnost za integraciju s drugim servisima i API-jima</li> </ul> <p>Prakti\u010dno, svaki put kada korisnik klikne dugme, popuni formu, ili kad aplikacija treba prikazati listu stavki \u2014 radi se neka vrsta manipulacije podacima.</p>"},{"location":"content/data-manipulation/#2-vrste-i-izvori-podataka-u-reactu","title":"2. Vrste i izvori podataka u Reactu","text":"<p>Podaci u React aplikacijama dolaze iz razli\u010ditih izvora, a razumijevanje izvora je klju\u010dno za pravilan dizajn aplikacije.</p> <p>Naj\u010de\u0161\u0107i izvori podataka:</p> <ul> <li>Lokalno stanje komponente (<code>useState</code>, <code>useReducer</code>)</li> <li>Props (podaci koje komponenta prima od roditelja)</li> <li>Globalno stanje (Context API, Redux, Zustand, Recoil, Jotai, MobX)</li> <li>Eksterni API ili baza podataka (REST API, GraphQL, Firebase...)</li> <li>URL parametri i ruter (React Router, search params, hash, pathname)</li> <li>Lokalna pohrana (LocalStorage, SessionStorage, IndexedDB)</li> <li>Cache sloj (React Query, SWR, Apollo Client...)</li> </ul>"},{"location":"content/data-manipulation/#3-osnovni-koncepti-manipulacije-podacima","title":"3. Osnovni koncepti manipulacije podacima","text":"<p>React Data Manipulation se odnosi na sve tehnike i obrasce kojima kontroliramo kako se podaci kre\u0107u kroz aplikaciju. Va\u017eno je shvatiti razliku izme\u0111u:</p> <ul> <li>Jednosmjernog toka podataka (data flow) \u2014 podaci idu od roditelja ka djetetu preko props-a.</li> <li>Dvosmjernog toka podataka \u2014 obi\u010dno posti\u017eemo preko callback funkcija ili state management alata.</li> </ul> <p>Kada planirate aplikaciju, uvijek postavite ova pitanja:</p> <ol> <li>Gdje nastaje podatak? (input, API, generisan kodom)</li> <li>Ko sve treba taj podatak?</li> <li>Ko smije da ga mijenja?</li> <li>Kako \u0107e promjena podatka utjecati na UI?</li> </ol>"},{"location":"content/data-manipulation/#4-koristenje-lokalnog-stanja-usestate","title":"4. Kori\u0161tenje lokalnog stanja (useState)","text":"<p>Lokalni state je najosnovniji na\u010din za upravljanje podacima unutar jedne komponente.</p> <pre><code>import { useState } from 'react';\n\nfunction Brojac() {\n  const [count, setCount] = useState(0);\n\n  const povecaj = () =&gt; setCount(prev =&gt; prev + 1);\n  const smanji = () =&gt; setCount(prev =&gt; prev - 1);\n  const resetiraj = () =&gt; setCount(0);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Trenutna vrijednost: {count}&lt;/p&gt;\n      &lt;button onClick={povecaj}&gt;+&lt;/button&gt;\n      &lt;button onClick={smanji}&gt;-&lt;/button&gt;\n      &lt;button onClick={resetiraj}&gt;Reset&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre> <p>Kada koristiti lokalni state?</p> <ul> <li>Kada podatak treba samo toj komponenti.</li> <li>Kada podatak ne uti\u010de na druge dijelove aplikacije.</li> <li>Za privremene UI efekte (modali, animacije, hover state...)</li> </ul>"},{"location":"content/data-manipulation/#5-props-prijenos-podataka-meu-komponentama","title":"5. Props: prijenos podataka me\u0111u komponentama","text":"<p>Props (properties) su osnovni na\u010din komunikacije od roditeljske ka djetetovoj komponenti. Props su read-only i ne mogu se mijenjati unutar djeteta.</p> <pre><code>function Pozdrav({ ime }) {\n  return &lt;h2&gt;Zdravo, {ime}!&lt;/h2&gt;;\n}\n\nfunction App() {\n  return &lt;Pozdrav ime=\"Amar\" /&gt;;\n}\n</code></pre> <p>Kako dijete \u0161alje podatke roditelju? Kroz callback funkciju proslije\u0111enu kao prop.</p> <pre><code>function Parent() {\n  const [poruka, setPoruka] = useState(\"\");\n\n  function primiPoruku(novaPoruka) {\n    setPoruka(novaPoruka);\n  }\n\n  return (\n    &lt;&gt;\n      &lt;Child posaljiRoditelju={primiPoruku} /&gt;\n      &lt;p&gt;Poruka iz djeteta: {poruka}&lt;/p&gt;\n    &lt;/&gt;\n  );\n}\n\nfunction Child({ posaljiRoditelju }) {\n  return &lt;button onClick={() =&gt; posaljiRoditelju(\"Pozdrav iz djeteta!\")}&gt;Po\u0161alji roditelju&lt;/button&gt;;\n}\n</code></pre>"},{"location":"content/data-manipulation/#6-podizanje-state-a-lifting-state-up","title":"6. Podizanje state-a (\"Lifting State Up\")","text":"<p>Kada dva ili vi\u0161e sibling komponenata treba da dijele podatke, najbolje rje\u0161enje je podi\u0107i state na njihovog zajedni\u010dkog roditelja.</p> <p>Primjer:</p> <pre><code>function Kontrola() {\n  const [vrijednost, setVrijednost] = useState(\"\");\n\n  return (\n    &lt;div&gt;\n      &lt;InputA vrijednost={vrijednost} setVrijednost={setVrijednost} /&gt;\n      &lt;InputB vrijednost={vrijednost} setVrijednost={setVrijednost} /&gt;\n      &lt;p&gt;Trenutna zajedni\u010dka vrijednost: {vrijednost}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\nfunction InputA({ vrijednost, setVrijednost }) {\n  return &lt;input value={vrijednost} onChange={e =&gt; setVrijednost(e.target.value)} placeholder=\"A\" /&gt;;\n}\n\nfunction InputB({ vrijednost, setVrijednost }) {\n  return &lt;input value={vrijednost} onChange={e =&gt; setVrijednost(e.target.value)} placeholder=\"B\" /&gt;;\n}\n</code></pre>"},{"location":"content/data-manipulation/#7-globalno-stanje-i-context-api","title":"7. Globalno stanje i Context API","text":"<p>Kada podaci trebaju da budu dostupni na vi\u0161e mjesta u aplikaciji (npr. user info, tema, jezik), koristi se Context API ili globalni state manageri.</p> <pre><code>import React, { createContext, useContext, useState } from \"react\";\n\nconst UserContext = createContext();\n\nfunction App() {\n  const [user, setUser] = useState({ ime: \"Ana\" });\n\n  return (\n    &lt;UserContext.Provider value={user}&gt;\n      &lt;Profil /&gt;\n    &lt;/UserContext.Provider&gt;\n  );\n}\n\nfunction Profil() {\n  const user = useContext(UserContext);\n  return &lt;h2&gt;Korisnik: {user.ime}&lt;/h2&gt;;\n}\n</code></pre> <p>Napomena: Nemojte koristiti Context za \u010desto mijenjane podatke ili velike objekte (mo\u017ee usporiti renderiranje).</p>"},{"location":"content/data-manipulation/#8-napredne-biblioteke-za-upravljanje-stanjem","title":"8. Napredne biblioteke za upravljanje stanjem","text":"<p>Za kompleksne aplikacije, \u010desto koristimo naprednije alate:</p> <ul> <li>Redux \u2014 industrijski standard, predvidiv, ali ima vi\u0161e boilerplate koda.</li> <li>Zustand \u2014 jednostavan i lagan, koristi hooks.</li> <li>Recoil, Jotai, MobX \u2014 savremene alternative za razli\u010dite potrebe.</li> <li>React Query / TanStack Query \u2014 za rad sa server state-om (fetch, cache, sync).</li> </ul> <p>Primjer Redux slice-a:</p> <pre><code>// features/user/userSlice.js\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst initialState = { ime: '', prijavljen: false };\n\nconst userSlice = createSlice({\n  name: 'user',\n  initialState,\n  reducers: {\n    prijavi: (state, action) =&gt; {\n      state.ime = action.payload;\n      state.prijavljen = true;\n    },\n    odjavi: (state) =&gt; {\n      state.ime = '';\n      state.prijavljen = false;\n    }\n  }\n});\n\nexport const { prijavi, odjavi } = userSlice.actions;\nexport default userSlice.reducer;\n</code></pre>"},{"location":"content/data-manipulation/#9-dohvacanje-podataka-s-api-ja-i-serverska-komunikacija","title":"9. Dohva\u0107anje podataka s API-ja i serverska komunikacija","text":"<p>Dohva\u0107anje podataka \u010desto se radi u <code>useEffect</code> hooku, ili pomo\u0107u biblioteka (React Query, SWR, Axios).</p> <pre><code>import React, { useState, useEffect } from \"react\";\n\nfunction ListaKorisnika() {\n  const [korisnici, setKorisnici] = useState([]);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() =&gt; {\n    fetch(\"https://jsonplaceholder.typicode.com/users\")\n      .then(res =&gt; res.json())\n      .then(data =&gt; {\n        setKorisnici(data);\n        setLoading(false);\n      });\n  }, []);\n\n  if (loading) return &lt;p&gt;U\u010ditavanje...&lt;/p&gt;;\n  return (\n    &lt;ul&gt;\n      {korisnici.map(k =&gt; (\n        &lt;li key={k.id}&gt;{k.name}&lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  );\n}\n</code></pre> <p>Bitne napomene: - Error handling: Uvijek hvataj gre\u0161ke kod dohvata podataka. - Cleanup: Ako koristi\u0161 async logiku u useEffect, vodi ra\u010duna o otkazivanju fetch-a.</p>"},{"location":"content/data-manipulation/#10-transformacija-filtriranje-i-prikaz-podataka","title":"10. Transformacija, filtriranje i prikaz podataka","text":"<p>U praksi, podatke \u010desto treba transformirati prije prikaza: filtrirati, sortirati, grupisati, mapirati.</p> <pre><code>const filtrirani = korisnici.filter(k =&gt; k.name.startsWith(\"A\"));\nconst sortirani = korisnici.sort((a, b) =&gt; a.name.localeCompare(b.name));\nconst imena = korisnici.map(k =&gt; k.name.toUpperCase());\n</code></pre> <p>Primjer prikaza filtrirane liste:</p> <pre><code>function PrikazFiltriranih({ korisnici }) {\n  const filtrirani = korisnici.filter(k =&gt; k.name.length &gt; 5);\n  return (\n    &lt;ul&gt;\n      {filtrirani.map(k =&gt; &lt;li key={k.id}&gt;{k.name}&lt;/li&gt;)}\n    &lt;/ul&gt;\n  );\n}\n</code></pre>"},{"location":"content/data-manipulation/#11-rad-sa-listama-i-kljucevima","title":"11. Rad sa listama i klju\u010devima","text":"<p>Svaki element u listi mora imati jedinstveni <code>key</code> prop. Najbolje koristiti ID iz baze.</p> <pre><code>const brojevi = [1, 2, 3, 4, 5];\n&lt;ul&gt;\n  {brojevi.map(broj =&gt; &lt;li key={broj}&gt;{broj}&lt;/li&gt;)}\n&lt;/ul&gt;\n</code></pre> <p>Za\u0161to ne koristiti index kao key? Ako se redoslijed promijeni, React mo\u017ee pogre\u0161no interpretirati koji je element koji, \u0161to vodi do bugova.</p>"},{"location":"content/data-manipulation/#12-optimizacija-performansi","title":"12. Optimizacija performansi","text":"<p>Za kompleksne aplikacije i velike podatke, koristi:</p> <ul> <li>useMemo \u2014 memorisanje izra\u010duna</li> <li>useCallback \u2014 memorisanje funkcija</li> <li>React.memo \u2014 sprje\u010dava nepotrebno renderiranje child komponenti</li> </ul> <pre><code>import { useMemo } from \"react\";\n\nfunction Lista({ podaci }) {\n  const sortirani = useMemo(\n    () =&gt; podaci.slice().sort((a, b) =&gt; a.ime.localeCompare(b.ime)),\n    [podaci]\n  );\n  // ...\n}\n</code></pre> <p>Primjer React.memo:</p> <pre><code>const Dugme = React.memo(function Dugme({ onClick, label }) {\n  return &lt;button onClick={onClick}&gt;{label}&lt;/button&gt;;\n});\n</code></pre>"},{"location":"content/data-manipulation/#13-forme-upravljanje-unosom-i-validacija","title":"13. Forme: upravljanje unosom i validacija","text":""},{"location":"content/data-manipulation/#131-kontrolirane-forme","title":"13.1 Kontrolirane forme","text":"<p>React forme se naj\u010de\u0161\u0107e rade kao kontrolirane komponente \u2014 vrijednost inputa se \u010duva u state-u.</p> <pre><code>function FormaImena() {\n  const [ime, setIme] = useState('');\n\n  function handleChange(event) {\n    setIme(event.target.value);\n  }\n\n  function handleSubmit(event) {\n    event.preventDefault();\n    alert('Uneseno ime: ' + ime);\n  }\n\n  return (\n    &lt;form onSubmit={handleSubmit}&gt;\n      &lt;input value={ime} onChange={handleChange} /&gt;\n      &lt;button type=\"submit\"&gt;Po\u0161alji&lt;/button&gt;\n    &lt;/form&gt;\n  );\n}\n</code></pre>"},{"location":"content/data-manipulation/#132-visestruki-inputi-i-objekat-u-state-u","title":"13.2 Vi\u0161estruki inputi i objekat u state-u","text":"<pre><code>function Rezervacija() {\n  const [unosi, setUnosi] = useState({\n    imeGosta: '',\n    brojGostiju: 1,\n    dolaziNaVeceru: true\n  });\n\n  function handleInputChange(event) {\n    const { name, type, value, checked } = event.target;\n    setUnosi(stari =&gt; ({\n      ...stari,\n      [name]: type === 'checkbox' ? checked : value\n    }));\n  }\n\n  // ... ostatak forme kao prije\n}\n</code></pre>"},{"location":"content/data-manipulation/#133-validacija-unosa","title":"13.3 Validacija unosa","text":"<p>Validaciju mo\u017ee\u0161 raditi ru\u010dno ili pomo\u0107u biblioteka (Formik, React Hook Form, Yup).</p> <pre><code>function FormaPrijave() {\n  const [email, setEmail] = useState('');\n  const [lozinka, setLozinka] = useState('');\n  const [greske, setGreske] = useState({});\n\n  function handleSubmit(event) {\n    event.preventDefault();\n    const noveGreske = {};\n    if (!email) {\n      noveGreske.email = 'Email je obavezan.';\n    } else if (!/\\S+@\\S+\\.\\S+/.test(email)) {\n      noveGreske.email = 'Email nije validan.';\n    }\n\n    if (!lozinka || lozinka.length &lt; 6) {\n      noveGreske.lozinka = 'Lozinka mora imati najmanje 6 znakova.';\n    }\n\n    setGreske(noveGreske);\n\n    if (Object.keys(noveGreske).length === 0) {\n      alert('Prijava uspje\u0161na!');\n    }\n  }\n\n  // ... ostatak komponente\n}\n</code></pre>"},{"location":"content/data-manipulation/#14-nekontrolirane-komponente-i-rad-s-ref-ovima","title":"14. Nekontrolirane komponente i rad s ref-ovima","text":"<p>Nekontrolirane komponente koriste se kada ne \u017eeli\u0161 da React upravlja vrijedno\u0161\u0107u inputa, nego direktno pristupa\u0161 DOM-u putem ref-a.</p> <pre><code>import React, { useRef } from 'react';\n\nfunction NekontrolisanaForma() {\n  const inputRef = useRef(null);\n\n  function handleSubmit(event) {\n    event.preventDefault();\n    alert('Vrijednost iz inputa: ' + inputRef.current.value);\n  }\n\n  return (\n    &lt;form onSubmit={handleSubmit}&gt;\n      &lt;input ref={inputRef} /&gt;\n      &lt;button type=\"submit\"&gt;Po\u0161alji&lt;/button&gt;\n    &lt;/form&gt;\n  );\n}\n</code></pre> <p>Kada koristiti? - Integracija sa starijim bibliotekama - File inputi (<code>&lt;input type=\"file\" /&gt;</code>) - Fokusiranje i selektovanje teksta</p>"},{"location":"content/data-manipulation/#15-kesiranje-i-lokalna-pohrana","title":"15. Ke\u0161iranje i lokalna pohrana","text":"<p>Za \u010duvanje podataka na klijent strani koristi se LocalStorage, SessionStorage, ili specijalizirane biblioteke.</p> <pre><code>// Spremanje podataka\nlocalStorage.setItem('tema', 'tamna');\n\n// Dohva\u0107anje podataka\nconst tema = localStorage.getItem('tema');\n</code></pre> <p>Napomena: Podaci u LocalStorage su stringovi, pa koristi JSON.stringify i JSON.parse za objekte.</p>"},{"location":"content/data-manipulation/#16-najcesce-greske-i-dobre-prakse","title":"16. Naj\u010de\u0161\u0107e gre\u0161ke i dobre prakse","text":"<ul> <li>Ne mijenjaj state direktno \u2014 koristi set funkcije.</li> <li>Ne koristi index kao key kod lista \u2014 koristi jedinstveni ID.</li> <li>Ne koristi Context API za podatke koji se \u010desto mijenjaju \u2014 mo\u017ee usporiti aplikaciju.</li> <li>Ne radi skupe operacije u render funkciji \u2014 koristi useMemo.</li> <li>Uvijek hvataj gre\u0161ke kod fetch-a \u2014 korisnik mora znati \u0161ta se de\u0161ava.</li> <li>Ne dupliciraj podatke u vi\u0161e mjesta \u2014 vodi brigu o izvoru istine (single source of truth).</li> <li>Rasporedi odgovornosti \u2014 neka svaka komponenta ima jasnu svrhu.</li> </ul>"},{"location":"content/data-manipulation/#17-napredne-teme-i-korisni-alati","title":"17. Napredne teme i korisni alati","text":"<ul> <li>Redux Toolkit \u2014 pojednostavljeno upravljanje Reduxom</li> <li>React Query / TanStack Query \u2014 automatsko ke\u0161iranje, refetch, stale-while-revalidate</li> <li>SWR \u2014 jednostavno ke\u0161iranje i revalidacija podataka</li> <li>Apollo Client \u2014 GraphQL client s cache-iranjem</li> <li>Zustand, Jotai, Recoil \u2014 moderne alternative Reduxu</li> <li>Immer \u2014 za imutabilno a\u017euriranje stanja bez puno koda</li> <li>XState \u2014 za modeliranje slo\u017eenih state-ova kao finite state machine</li> </ul>"},{"location":"content/data-manipulation/#19-dodatni-resursi","title":"19. Dodatni resursi","text":"<ul> <li>React dokumentacija</li> <li>React Patterns</li> <li>Awesome React</li> <li>Redux Toolkit</li> <li>React Query</li> <li>Formik</li> <li>React Hook Form</li> <li>GraphQL</li> </ul> <p>Napomena: Ovu dokumentaciju slobodno koristi, prilagodi i pro\u0161iri prema potrebama svog projekta ili tima. Prakti\u010dni primjeri su tu da olak\u0161aju razumijevanje, ali uvijek eksperimentiraj i istra\u017euj slu\u017ebenu dokumentaciju za najnovije najbolje prakse i alate.</p>"},{"location":"content/introduction/","title":"Introduction to Web Development and Version Control System","text":""},{"location":"content/introduction/#sta-je-web-development","title":"\u0160ta je web development?","text":"<p>Web development je proces pravljenja i odr\u017eavanja web stranica i aplikacija. Dakle, sve \u0161to radite na internetu \u2013 bilo da \u010ditate vijesti, gledate YouTube, kupujete ne\u0161to online ili provjeravate raspored predavanja \u2013 sve to je rezultat web developmenta.</p> <p>Tu razlikujemo dva velika dijela:</p> <p>\ud83d\udd39 1. Frontend (klijentska strana)</p> <p>Frontend je sve ono \u0161to korisnik vidi i koristi \u2013 izgled stranice, dugmad, slike, boje, meni, tekst\u2026 To je vizuelni dio aplikacije.</p> <p>Tehnologije koje se koriste u frontendu su:</p> <p>HTML \u2013 pravi strukturu stranice. Zamislite HTML kao kostur web stranice \u2013 odre\u0111uje gdje ide naslov, paragraf, dugme, slika.</p> <p>CSS \u2013 daje stil i ljepotu toj strukturi. CSS odre\u0111uje boje, raspored, fontove, margine. On ure\u0111uje kako stranica izgleda.</p> <p>JavaScript \u2013 daje stranici \u017eivot. On omogu\u0107ava da ne\u0161to reaguje kada kliknemo dugme, da se prikazuje/skriva sadr\u017eaj, da se automatski ra\u010duna neka vrijednost.</p>"},{"location":"content/introduction/#2-backend-serverska-strana","title":"2. Backend (serverska strana)","text":"<p>S druge strane imamo backend \u2013 to je nevidljivi dio, koji korisnik ne vidi, ali bez kojeg ni\u0161ta ne bi funkcionisalo.</p> <p>Backend se brine o:</p> <p>-prijavi korisnika,</p> <p>-spremanju podataka (npr. proizvoda, korisni\u010dkih ra\u010duna),</p> <p>-komunikaciji s bazom podataka,</p> <p>-sigurnosti podataka.</p> <p>Tehnologije koje se tu koriste su: Node.js, Python, PHP, Java, te baze podataka kao MySQL, MongoDB i drugi.</p>"},{"location":"content/introduction/#kako-frontend-i-backend-sarauju","title":"Kako frontend i backend sara\u0111uju?","text":"<p>Frontend \u0161alje zahtjev \u2013 npr. \u201cDaj mi korisni\u010dke podatke\u201d</p> <p>Backend provjerava bazu i vra\u0107a te podatke</p> <p>Frontend ih prikazuje korisniku</p>"},{"location":"content/introduction/#sta-je-reactjs","title":"\u0160ta je React.js?","text":"<p>React je moderna JavaScript biblioteka koju je razvio Facebook.</p> <p>Slu\u017ei za kreiranje korisni\u010dkog interfejsa (UI), ali na efikasniji i modularniji na\u010din.</p> <p>Zamislite web aplikaciju kao LEGO ku\u0107u:</p> <p>Svaka LEGO kockica je komponenta \u2013 dugme, kartica, meni, forma.</p> <p>Komponente mo\u017eemo vi\u0161e puta koristiti i kombinovati bez da svaki put pi\u0161emo sve ispo\u010detka.</p> <p>React omogu\u0107ava da aplikaciju gradimo iz tih malih, ponovo iskoristivih dijelova, \u0161to je savr\u0161eno za velike i kompleksne projekte.</p>"},{"location":"content/introduction/#kreiranje-react-projekta-pomocu-vite-a","title":"Kreiranje React projekta pomo\u0107u Vite-a","text":"<p>Kako uop\u0161te pravimo React aplikaciju?</p> <p>Nekada smo koristili alat koji se zvao Create React App (CRA). Me\u0111utim, danas postoji br\u017ei i lak\u0161i alat \u2013 Vite.</p> <p>\ud83d\udd39 \u0160ta je Vite?</p> <p>Vite (\u010dita se: vit) je moderni build alat koji nam poma\u017ee da brzo postavimo React aplikaciju.</p> <p>Koristi nove tehnologije u pozadini (kao \u0161to je ESM \u2013 ECMAScript Modules).</p> <p>Mnogo je br\u017ei od starog CRA-a, naro\u010dito kada radimo lokalno u razvoju.</p> <p>\ud83d\udccc Zamislite Vite kao alat koji umjesto nas postavlja sav osnovni React kod i folder strukturu \u2013 tako da ne moramo pisati sve od nule.</p> <p>\ud83d\udd39 Priprema: Instalacija Node.js</p> <p>Da bismo koristili Vite i React, prvo moramo imati Node.js instaliran.</p> <p>\ud83d\udd27 Node.js je program koji nam omogu\u0107ava da u komandnoj liniji pokre\u0107emo JavaScript i upravljamo projektima.</p> <p>\u2705 Kada instaliramo Node.js, automatski dobijamo i npm \u2013 to je alat koji nam omogu\u0107ava instalaciju React-a i drugih paketa.</p> <p>\ud83d\udce5 Koraci:</p> <p>Otvorimo https://nodejs.org</p> <p>Skinemo verziju ozna\u010denu kao \"LTS\" (Long Term Support)</p> <p>Instaliramo je klikom \"Next \u2192 Next\" kao i bilo koji drugi program</p>"},{"location":"content/introduction/#kreiranje-projekta-pomocu-vite-a","title":"Kreiranje projekta pomo\u0107u Vite-a","text":"<p>Nakon \u0161to imamo Node.js, otvaramo terminal (ili VS Code terminal) i kucamo sljede\u0107e komande:</p> <p>npm create vite@latest my-react-app -- --template react cd my-react-app npm install npm run dev</p> <p>\u0160ta ove komande rade?</p> <p>npm create vite@latest my-react-app \u2192 ka\u017ee: napravi novi projekat koriste\u0107i Vite, pod nazivom my-react-app, i neka koristi React kao \u0161ablon</p> <p>cd my-react-app \u2192 ulazimo u na\u0161 novi folder s projektom</p> <p>npm install \u2192 instaliramo sve zavisnosti (biblioteke koje su potrebne za rad)</p> <p>npm run dev \u2192 pokre\u0107emo razvojni server, i aplikacija se otvara u browseru</p> <p>\ud83d\udda5\ufe0f Nakon npm run dev, terminal nam da lokalni link, npr. http://localhost:5173, koji otvorimo u browseru i odmah vidimo po\u010detnu React stranicu.</p>"},{"location":"content/introduction/#otvaranje-projekta-u-vs-code","title":"Otvaranje projekta u VS Code","text":"<p>Ako koristimo Visual Studio Code, projekat mo\u017eemo otvoriti ovako:</p> <p>code .</p> <p>To \u0107e otvoriti trenutni folder u VS Code-u, i mo\u017eemo odmah po\u010deti ure\u0111ivati kod.</p> <p>\ud83d\udccc Ako ova komanda ne radi, mo\u017eda treba dodati VS Code u PATH tokom instalacije \u2013 to se mo\u017ee naknadno uklju\u010diti.</p>"},{"location":"content/introduction/#pitanja-i-dodatni-savjeti","title":"Pitanja i dodatni savjeti","text":"<p>Ako dobijete gre\u0161ku tokom instalacije: provjerite da li imate Node.js i da li ste u pravom folderu.</p> <p>Ako je npm run dev uspio, to zna\u010di da sve radi i spremni ste da po\u010dnete s ure\u0111ivanjem aplikacije.</p>"},{"location":"content/introduction/#struktura-react-projekta-vite-objasnjenje","title":"\ud83d\udcc1 Struktura React projekta (Vite) \u2013 Obja\u0161njenje","text":"<p>Kada smo uspje\u0161no pokrenuli React aplikaciju pomo\u0107u Vite-a, hajde da zajedno pogledamo \u0161ta smo to zapravo dobili u projektu i \u010demu \u0161ta slu\u017ei.</p>"},{"location":"content/introduction/#1-node_modules","title":"\ud83d\udcc1 1. node_modules/","text":"<p>Ovo je folder koji sadr\u017ei sve biblioteke i pakete koje je na\u0161 projekat instalirao pomo\u0107u npm install.</p> <p>Ne diramo ga ru\u010dno!</p> <p>Automatski se kreira.</p> <p>Zato se dodaje u .gitignore kako ne bi i\u0161ao na GitHub jer je ogroman.</p>"},{"location":"content/introduction/#2-public","title":"\ud83d\udcc1 2. public/","text":"<p>Ovaj folder sadr\u017ei staticke fajlove koji se ne obra\u0111uju od strane React-a. Sve \u0161to stavimo ovdje bi\u0107e dostupno direktno u browseru.</p> <p>Npr. slike, favicon (ikonica stranice), dokumenti.</p> <p>\ud83d\udccc Primjer: ako ovdje dodamo fajl logo.png, mo\u017eemo mu pristupiti putem URL-a: http://localhost:5173/logo.png.</p>"},{"location":"content/introduction/#3-indexhtml","title":"\ud83d\udcc4 3. index.html","text":"<p>Ovo je HTML \u0161ablon na\u0161e aplikacije. Iako radimo s React-om (koji koristi JavaScript), cijela aplikacija se ipak \u201culiva\u201d u ovaj jedan HTML fajl.</p> <p>\ud83d\udd0d Pogledaj liniju:</p> <p>\u2192 React ubacuje kompletan sadr\u017eaj aplikacije unutar ovog div elementa. To se de\u0161ava u fajlu main.jsx.</p> <p>\ud83c\udfa4 \u201cIako ne pi\u0161emo puno HTML-a direktno ovdje, ovaj fajl je klju\u010dan jer predstavlja osnovu aplikacije.\u201d</p>"},{"location":"content/introduction/#4-src-najvazniji-folder","title":"\ud83d\udcc1 4. src/ \u2013 Najva\u017eniji folder","text":"<p>Ovdje se nalazi sav na\u0161 React kod. To je mjesto gdje pi\u0161emo komponente, stilove, logiku aplikacije.</p>"},{"location":"content/introduction/#mainjsx","title":"\ud83d\udcc4 main.jsx","text":"<p>Ovo je ulazna ta\u010dka aplikacije. Ovdje React povezuje App.jsx sa index.html.</p> <p>U kodu obi\u010dno vidimo:</p> <p>ReactDOM.createRoot(document.getElementById('root')).render(     );</p> <p>To zna\u010di: uzmi  komponentu i ubaci je u div koji ima id=\"root\" \u2013 upravo onaj u index.html.</p>"},{"location":"content/introduction/#appjsx","title":"\ud83d\udcc4 App.jsx","text":"<p>Ovo je glavna komponenta aplikacije \u2013 mo\u017eemo je zamisliti kao srce svega.</p> <p>Ovdje prikazujemo sve ostale komponente: navigaciju, kartice, forme, itd.</p> <p>Svaki novi dio koji pravimo, na kraju u\u0111e ovdje.</p> <p>Svaki React projekat ima App kao centralni prikaz, a ostale komponente dodajemo i prikazujemo unutar njega.</p>"},{"location":"content/introduction/#assets","title":"\ud83d\udcc1 assets/","text":"<p>Folder za slike, ikone, stilove koje koristimo u aplikaciji. Na slici vidimo npr. react.svg \u2013 to je logo koji se pojavljuje na po\u010detnoj stranici aplikacije.</p>"},{"location":"content/introduction/#appcss-i-indexcss","title":"\ud83d\udcc4 App.css i index.css","text":"<p>App.css \u2013 stilovi koji se odnose na App.jsx komponentu.</p> <p>index.css \u2013 globalni stilovi koji va\u017ee za cijelu aplikaciju.</p> <p>Mo\u017eemo ih ure\u0111ivati, dodavati svoje klase i praviti svoj dizajn.</p>"},{"location":"content/introduction/#ostali-vazni-fajlovi","title":"\ud83d\udcc4 Ostali va\u017eni fajlovi","text":""},{"location":"content/introduction/#gitignore","title":"\ud83d\udcc4 .gitignore","text":"<p>Ovdje pi\u0161emo koje fajlove i foldere ne \u017eelimo da \u0161aljemo na GitHub. Na primjer:</p> <p>node_modules dist .env</p>"},{"location":"content/introduction/#packagejson","title":"\ud83d\udcc4 package.json","text":"<p>Vrlo va\u017ean fajl. On sadr\u017ei:</p> <p>-naziv aplikacije</p> <p>-sve instalirane biblioteke (dependencies)</p> <p>-skripte koje mo\u017eemo pokretati (npr. npm run dev)</p> <p>-verziju projekta</p> <p>Ukoliko \u017eelite da vidite \u0161ta je instalirano u projektu, samo otvorite ovaj fajl i pogledajte dio dependencies.</p>"},{"location":"content/introduction/#viteconfigjs","title":"\ud83d\udcc4 vite.config.js","text":"<p>Konfiguracija za Vite alat. Ne\u0107emo ga puno dirati za osnovne projekte, ali kad budemo radili naprednije stvari kao aliasi, proxy, pluginovi \u2013 ovo je mjesto gdje se sve pode\u0161ava.</p>"},{"location":"content/introduction/#readmemd","title":"\ud83d\udcc4 README.md","text":"<p>Tekstualni fajl u kojem mo\u017eemo napisati osnovne informacije o projektu. Na GitHub-u se on prikazuje automatski na po\u010detnoj stranici repozitorija.</p>"},{"location":"content/introduction/#git-i-github-osnove-verzionisanja","title":"Git i GitHub \u2013 Osnove verzionisanja","text":""},{"location":"content/introduction/#sta-je-git","title":"\u0160ta je Git?","text":"<p>Git je verzioni sistem \u2013 alat koji pamti svaku promjenu koju napravimo u projektu.</p> <p>Zamislite ga kao vremensku ma\u0161inu:</p> <p>Svaka promjena koju napravimo se zabilje\u017ei kao snapshot.</p> <p>Mo\u017eemo se vratiti unazad, vidjeti ko je \u0161ta promijenio, kada, i za\u0161to.</p> <p>Idealno za timski rad \u2013 vi\u0161e ljudi mo\u017ee raditi istovremeno, a da se ne pregazi kod.</p> <p>\ud83d\udccc Git omogu\u0107ava programerima da znaju:</p> <p>\u2705 Ko je napravio promjenu</p> <p>\u2705 Kada je napravljena</p> <p>\u2705 \u0160ta je ta\u010dno promijenjeno</p> <p>\u2705 Za\u0161to je promjena uvedena (kroz opis \u2013 commit message)</p>"},{"location":"content/introduction/#sta-je-github","title":"\ud83d\udd39 \u0160ta je GitHub?","text":"<p>GitHub je online platforma koja \u010duva Git projekte u cloud-u.</p> <p>Tu pohranjujemo svoj kod i dijelimo ga s drugima</p> <p>Mo\u017eemo raditi u timovima, otvarati zadatke (issues), praviti grane (branches), recenzirati kod (pull requests)</p>"},{"location":"content/introduction/#kako-git-funkcionise","title":"Kako Git funkcioni\u0161e?","text":"<p>Zamislimo da radimo na dokumentu:</p> <p>Kada napi\u0161emo dio koda, pripremimo ga za snimanje (git add)</p> <p>Onda snimimo promjenu s opisom (git commit)</p> <p>I po \u017eelji po\u0161aljemo to na GitHub (git push)</p> <p>Git \u010duva istoriju svake te promjene u obliku commit-a, a svi commit-i zajedno \u010dine istoriju projekta.</p>"},{"location":"content/introduction/#glavne-komande-u-git-u","title":"\ud83d\udcc4 Glavne komande u Git-u","text":"<p>Komanda                     \u0160ta radi git init                      Inicijalizuje prazan Git repozitorij git add .                     Priprema sve fajlove za commit git commit -m \"opis\"          Snima promjene sa porukom git status                  Prikazuje trenutno stanje fajlova git clone              Klonira GitHub repozitorij na ra\u010dunar git branch                  Prikazuje (ili pravi) grane git merge                     Spaja promjene iz druge grane git pull                      Preuzima promjene s GitHub-a git push                      \u0160alje promjene na GitHub"},{"location":"content/introduction/#branching-grane","title":"Branching (grane)","text":"<p>Svaka grana je paralelna linija razvoja.</p> <p>main je glavna verzija.</p> <p>Mo\u017eemo napraviti grane za testiranje, nove funkcije, ispravke gre\u0161aka itd.</p> <p>git branch nova-funkcija git checkout nova-funkcija</p> <p>Branching je kao da pravite kopiju projekta da biste eksperimentisali bez straha da ne\u0161to pokvarite.</p>"},{"location":"content/introduction/#commit-snapshoti","title":"Commit snapshoti","text":"<p>Svaki commit je kao fotografija trenutnog stanja projekta. Zahvaljuju\u0107i tome mo\u017eemo:</p> <p>-Vratiti se na bilo koji prethodni commit</p> <p>-Pratiti promjene po datumu i autoru</p> <p>-Pregledati historiju promjena</p>"},{"location":"content/introduction/#github-u-praksi","title":"GitHub u praksi","text":"<p>Kreiramo repozitorij na GitHub-u (bez README ako ve\u0107 imamo fajlove)</p> <p>Na ra\u010dunaru koristimo:</p> <p>git init git remote add origin https://github.com/ime/repo.git git add . git commit -m \"Initial commit\" git branch -M main git push -u origin main</p> <p>Nakon toga, sve naredne promjene pratimo i \u0161aljemo pomo\u0107u add \u2192 commit \u2192 push.</p>"},{"location":"content/introduction/#pull-request-i-saradnja","title":"Pull Request i saradnja","text":"<p>Kada radimo u timu, pravimo granu i tra\u017eimo odobrenje putem Pull Requesta.</p> <p>Tu tim mo\u017ee:</p> <p>dodati komentare,</p> <p>zatra\u017eiti izmjene,</p> <p>spojiti promjene u main.</p>"},{"location":"content/introduction/#prakticna-git-i-github-vjezba","title":"Prakti\u010dna Git i GitHub vje\u017eba","text":"<p>\ud83c\udfaf Cilj: Nau\u010diti kako se kreira Git repozitorij, kako se prate promjene, i kako se sve \u0161alje na GitHub.</p> <p>\ud83d\udd39 1. Inicijalizacija Git repozitorija</p> <p>U VS Code terminalu (ili obi\u010dnom terminalu) kucati:</p> <p>git init</p> <p>\ud83d\udcdd Ovo kreira .git folder i omogu\u0107ava Git-u da prati promjene u ovom projektu.</p> <p>\ud83d\udd39 2. Dodavanje fajlova za pra\u0107enje git add .</p> <p>\ud83d\udccc Ova komanda dodaje sve fajlove u tzv. \u201cstaging area\u201d \u2013 zna\u010di priprema ih za snimanje.</p> <p>Ako \u017eelimo samo jedan fajl: git add imeFajla.ext</p> <p>\ud83d\udd39 3. Kreiranje prvog commita git commit -m \"Initial commit\"</p> <p>Ovim \u010duvamo stanje projekta s opisom. Po\u017eeljno je da opis bude kratak i jasan.</p>"},{"location":"content/introduction/#4-kreiranje-github-repozitorija","title":"4. Kreiranje GitHub repozitorija","text":"<p>\u27a1\ufe0f Oti\u0107i na https://github.com</p> <p>\u27a1\ufe0f Kliknuti New Repository \u27a1\ufe0f Nazvati ga npr. my-first-react-app \u27a1\ufe0f Ne dodavati README jer ga ve\u0107 imamo lokalno \u27a1\ufe0f Kliknuti Create repository</p>"},{"location":"content/introduction/#5-povezivanje-lokalnog-repozitorija-sa-github-om","title":"5. Povezivanje lokalnog repozitorija sa GitHub-om","text":"<p>git remote add origin https://github.com/korisnickoime/my-first-react-app.git</p>"},{"location":"content/introduction/#6-postavljanje-glavne-grane-main","title":"6. Postavljanje glavne grane (main)","text":"<p>git branch -M main</p>"},{"location":"content/introduction/#7-slanje-koda-na-github","title":"7. Slanje koda na GitHub","text":"<p>git push -u origin main</p> <p>Ako se tra\u017ei username i password, korisnici treba da koriste GitHub token umjesto lozinke (mo\u017ee se generisati iz GitHub Settings &gt; Developer Settings &gt; Tokens).</p> <p>Otvoriti GitHub repozitorij \u2013 u\u010desnici \u0107e sada vidjeti svoj kod online!</p>"},{"location":"content/introduction/#dodatni-zadaci-za-samostalan-rad","title":"Dodatni zadaci za samostalan rad","text":"<p>Napravi novu granu:</p> <p>git checkout -b nova-funkcija</p> <p>Uredi jedan fajl i commitaj promjenu:</p> <p>git add . git commit -m \"Dodana nova funkcija\"</p> <p>Vrati se na main i spoji promjene (napredno):</p> <p>git checkout main git merge nova-funkcija</p>"},{"location":"content/introduction/#qa-i-zajednicki-problemi","title":"Q&amp;A i Zajedni\u010dki problemi","text":""},{"location":"content/introduction/#1-sta-ako-zaboravimo-git-add","title":"1. \u0160ta ako zaboravimo git add?","text":"<p>Problem: Napravili ste izmjenu u fajlu, uradili git commit, ali promjena nije snimljena.</p> <p>Obja\u0161njenje: Git mo\u017ee da commit-uje samo ono \u0161to je prethodno dodano sa git add. Ako to presko\u010dimo, promjene ostaju \u201enevidljive\u201c za Git.</p> <p>Rje\u0161enje:</p> <p>Provjerite stanje:</p> <p>git status</p> <p>Vidjet \u0107ete koji su fajlovi izmijenjeni, ali nisu \u201estaged\u201c.</p> <p>Dodajte ih i uradite commit:</p> <p>git add naziv_fajla git commit -m \"Dodaj pravi opis\"</p> <p>Savjet: uvijek koristite git status prije commita da provjerite \u0161ta je dodano.</p>"},{"location":"content/introduction/#2-kako-vratiti-stariju-verziju-fajla","title":"2. Kako vratiti stariju verziju fajla?","text":"<p>a) Vratiti fajl na stanje iz zadnjeg commit-a:</p> <p>Ako \u017eelite odbaciti lokalne promjene:</p> <p>git restore naziv_fajla</p> <p>Ova komanda \u0107e izbrisati sve izmjene u fajlu i vratiti ga na posljednju verziju iz repozitorija.</p> <p>b) Vratiti cijeli projekat na raniji commit:</p> <p>Prona\u0111i ID commita:</p> <p>git log</p> <p>Vrati se na \u017eeljeni commit (privremeno):</p> <p>git checkout  <p>Napomena: ovo vas stavlja u \u201edetached HEAD\u201c mod, \u0161to zna\u010di da gledate staru verziju i da ne treba praviti nove promjene direktno u tom stanju.</p> <p>Ako \u017eeli\u0161 da napravi\u0161 novu granu iz tog stanja:</p> <p>git checkout -b fix-old-version</p>"},{"location":"content/introduction/#3-kako-se-kreira-gitignore","title":"3. Kako se kreira .gitignore?","text":"<p>.gitignore je fajl u koji pi\u0161emo imena fajlova i foldera koje ne \u017eelimo da Git prati.</p> <p>Naj\u010de\u0161\u0107e se koristi da ignori\u0161emo:</p> <p>node_modules/</p> <p>dist/</p> <p>.env</p> <p>privremene .log fajlove</p> <p>Kako ga napraviti:</p> <p>U korijenu projekta klikni New File</p> <p>Nazovi ga .gitignore (bez ekstenzije)</p> <p>U njega upi\u0161i:</p> <p>node_modules/ dist/ .env *.log</p> <p>Git \u0107e automatski ignorisati sve \u0161to je tu navedeno.</p> <p>Ovo je korisno da ne \u0161aljemo stvari koje ne trebaju biti na GitHub-u \u2013 kao \u0161to su ogromni folderi, lokalne konfiguracije ili tajni podaci.</p>"},{"location":"content/react-library/","title":"React.js: Izgradnja Modernih Korisni\u010dkih Interfejsa","text":"<p>Dobrodo\u0161li u sveobuhvatni vodi\u010d za React.js, JavaScript biblioteku koja je revolucionirala na\u010din na koji gradimo dinami\u010dke i interaktivne korisni\u010dke interfejse. Ovaj kurikulum je pa\u017eljivo dizajniran da vas provede kroz klju\u010dne aspekte React-a, po\u010dev\u0161i od osnovnih koncepata i postavljanja razvojnog okru\u017eenja, pa sve do naprednijih tema poput upravljanja stanjem, komunikacije me\u0111u komponentama i rada s formama. Na\u0161 cilj je da vam pru\u017eimo \u010dvrste temelje i duboko razumijevanje principa na kojima po\u010divaju moderne React aplikacije, osposobljavaju\u0107i vas da samostalno kreirate sofisticirane web aplikacije.</p> <p>Bilo da ste po\u010detnik u svijetu web razvoja ili iskusni programer koji \u017eeli pro\u0161iriti svoje vje\u0161tine, ovaj vodi\u010d \u0107e vam pomo\u0107i da savladate React i iskoristite njegov puni potencijal.</p>"},{"location":"content/react-library/#dobrodosli-u-svijet-react-a","title":"Dobrodo\u0161li u Svijet React-a","text":""},{"location":"content/react-library/#sta-je-react","title":"\u0160ta je React?","text":"<p>React je deklarativna, efikasna i izuzetno fleksibilna JavaScript biblioteka otvorenog koda, stvorena i odr\u017eavana od strane kompanije Meta (nekada\u0161nji Facebook) zajedno sa zajednicom individualnih developera i kompanija. Primarna svrha React-a je olak\u0161avanje izgradnje kompleksnih, interaktivnih korisni\u010dkih interfejsa (UI) za web aplikacije. Ono \u0161to React izdvaja je njegov komponentni pristup razvoju.</p> <p>Zamislite korisni\u010dki interfejs kao skupinu Lego kockica. Svaka kockica (komponenta u React-u) je nezavisna, ima svoju specifi\u010dnu funkciju i izgled, i mo\u017ee se kombinovati sa drugim kockicama da bi se izgradila ve\u0107a i slo\u017eenija struktura (kompletna aplikacija). Ove komponente mogu biti jednostavne kao dugme ili input polje, ili slo\u017eene kao \u010ditava navigaciona traka ili korisni\u010dki profil.</p> <p>React se fokusira na \"V\" u MVC (Model-View-Controller) arhitekturi, odnosno na View sloj \u2013 ono \u0161to korisnik vidi i sa \u010dime interaguje. On ne name\u0107e stroga pravila o tome kako strukturirati ostatak aplikacije (npr. upravljanje podacima ili rutiranje), \u0161to mu daje fleksibilnost da se integri\u0161e sa mnogim drugim bibliotekama i framework-ovima.</p>"},{"location":"content/react-library/#zasto-koristiti-react","title":"Za\u0161to koristiti React?","text":"<ul> <li>\u2714\ufe0f Jednostavan model programiranja baziran na komponentama: React-ov komponentni model omogu\u0107ava lako razumijevanje i odr\u017eavanje koda. Svaka komponenta je izolovana i mo\u017ee se razvijati, testirati i koristiti nezavisno.</li> <li>\u2714\ufe0f Visoke performanse zahvaljuju\u0107i Virtual DOM-u: React koristi Virtual DOM - laganu kopiju stvarnog DOM-a. Kada do\u0111e do promjene, React prvo a\u017eurira Virtual DOM, a zatim efikasno sinhronizuje samo one delove stvarnog DOM-a koji su se promenili. Ovo zna\u010dajno pobolj\u0161ava performanse, posebno u slo\u017eenim i dinami\u010dnim aplikacijama.</li> <li>\u2714\ufe0f Bogati ekosistem i aktivna zajednica: Kao jedna od najpopularnijih JavaScript biblioteka, React ima ogroman ekosistem alata, biblioteka i resursa. Bez obzira na to da li vam je potrebna pomo\u0107 oko specifi\u010dnog problema ili \u017eelite da nau\u010dite najbolje prakse, velika je verovatno\u0107a da ve\u0107 postoji re\u0161enje ili vodi\u010d u React zajednici.</li> <li>\u2714\ufe0f Podr\u0161ka za server-side rendering i mobilne aplikacije (React Native): React se mo\u017ee koristiti ne samo za izradu web aplikacija, ve\u0107 i za razvoj mobilnih aplikacija putem React Native-a, kao i za server-side rendering, \u0161to dodatno pove\u0107ava njegovu svestranost i primenu.</li> </ul>"},{"location":"content/react-library/#spa-single-page-applications","title":"\u25b8 SPA: Single Page Applications","text":"<p>React aplikacije se obi\u010dno razvijaju kao SPA: stranica se u\u010ditava samo jednom, a svi ostali podaci se u\u010ditavaju dinami\u010dki putem JavaScript-a, bez reloadovanja cijele stranice.</p>"},{"location":"content/react-library/#postavljanje-okruzenja","title":"\u25b8 Postavljanje okru\u017eenja","text":"<ol> <li>Instalirati Node.js</li> <li>Inicijalizacija projekta pomo\u0107u <code>npm</code>, <code>yarn</code>, <code>pnpm</code></li> <li>Kreiranje projekta:    <pre><code>npm create vite@latest moja-react-aplikacija -- --template react\ncd moja-react-aplikacija\nnpm install\nnpm run dev\n</code></pre></li> </ol>"},{"location":"content/react-library/#osnove-react-a","title":"Osnove React-a","text":"<p>React se temelji na nekoliko klju\u010dnih koncepata koji omogu\u0107avaju njegovu mo\u0107 i fleksibilnost. Razumijevanje ovih osnova klju\u010dno je za efikasno kori\u0161tenje React-a.</p>"},{"location":"content/react-library/#jsx-javascript-xml","title":"JSX (JavaScript XML)","text":"<p>JSX je sintaksna ekstenzija za JavaScript koja omogu\u0107ava pisanje HTML-olikog koda unutar JavaScript datoteka. Iako nije obavezan za kori\u0161tenje React-a, JSX olak\u0161ava kreiranje i razumijevanje strukture korisni\u010dkog interfejsa.</p> <p>Primjer JSX-a:</p> <pre><code>const element = &lt;h1&gt;Zdravo, svijete!&lt;/h1&gt;;\n</code></pre> <p>Ovaj kod izgleda kao HTML, ali je zapravo JavaScript. Babel kompajler prevodi JSX u <code>React.createElement()</code> pozive. Gornji primjer bi bio preveden u:</p> <pre><code>const element = React.createElement('h1', null, 'Zdravo, svijete!');\n</code></pre> <p>Ugra\u0111ivanje izraza u JSX:</p> <p>Mo\u017eete ugraditi bilo koji JavaScript izraz unutar viti\u010dastih zagrada <code>{}</code> u JSX-u.</p> <pre><code>const ime = 'React Developer';\nconst element = &lt;h1&gt;Zdravo, {ime}!&lt;/h1&gt;;\n</code></pre> <p>Atributi u JSX-u:</p> <p>JSX koristi camelCase konvenciju za nazive atributa (npr. <code>className</code> umjesto <code>class</code>, <code>onClick</code> umjesto <code>onclick</code>).</p> <pre><code>const element = &lt;div className=\"pozdrav\"&gt;Zdravo!&lt;/div&gt;;\n</code></pre>"},{"location":"content/react-library/#komponente","title":"Komponente","text":"<p>Komponente su osnovni gradivni blokovi React aplikacija. One su nezavisni, ponovno upotrebljivi dijelovi koda koji enkapsuliraju logiku i prikaz odre\u0111enog dijela korisni\u010dkog interfejsa. Postoje dvije glavne vrste komponenata:</p> <p>Funkcionalne komponente:</p> <p>Jednostavne JavaScript funkcije koje primaju <code>props</code> (svojstva) kao argument i vra\u0107aju React elemente koji opisuju \u0161ta treba biti prikazano na ekranu.</p> <pre><code>function Pozdrav(props) {\n  return &lt;h1&gt;Zdravo, {props.ime}!&lt;/h1&gt;;\n}\n\n// Kori\u0161tenje komponente\nconst element = &lt;Pozdrav ime=\"Student\" /&gt;;\n</code></pre> <p>Klasne komponente (Legacy):</p> <p>ES6 klase koje naslje\u0111uju <code>React.Component</code> i imaju <code>render()</code> metodu koja vra\u0107a React elemente. Iako su funkcionalne komponente s Hooks API-jem postale dominantan na\u010din pisanja komponenata, va\u017eno je razumjeti i klasne komponente jer se mogu na\u0107i u starijim projektima.</p> <pre><code>class PozdravKlasa extends React.Component {\n  render() {\n    return &lt;h1&gt;Zdravo, {this.props.ime}!&lt;/h1&gt;;\n  }\n}\n\n// Kori\u0161tenje komponente\nconst element = &lt;PozdravKlasa ime=\"Student\" /&gt;;\n</code></pre>"},{"location":"content/react-library/#props-svojstva","title":"Props (Svojstva)","text":"<p><code>Props</code> (skra\u0107eno od properties) su na\u010din na koji komponente primaju podatke od svojih roditeljskih komponenata. Props su read-only, \u0161to zna\u010di da komponenta ne smije mijenjati props koje je primila.</p> <pre><code>function KorisnikKartica(props) {\n  return (\n    &lt;div className=\"korisnik-kartica\"&gt;\n      &lt;h2&gt;{props.korisnickoIme}&lt;/h2&gt;\n      &lt;p&gt;Email: {props.email}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\n// Proslije\u0111ivanje props-a\n&lt;KorisnikKartica korisnickoIme=\"AnaAnic\" email=\"ana.anic@example.com\" /&gt;\n</code></pre>"},{"location":"content/react-library/#state-stanje","title":"State (Stanje)","text":"<p><code>State</code> omogu\u0107ava komponentama da kreiraju i upravljaju vlastitim podacima koji se mogu mijenjati tokom vremena. Kada se stanje komponente promijeni, React automatski ponovno renderira komponentu kako bi prikazao a\u017eurirane podatke.</p> <p>Kori\u0161tenje state-a u funkcionalnim komponentama (sa <code>useState</code> Hook-om):</p> <pre><code>import React, { useState } from 'react';\n\nfunction Brojac() {\n  // Deklaracija state varijable 'broj' i funkcije 'postaviBroj' za njezino a\u017euriranje\n  const [broj, postaviBroj] = useState(0);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Trenutni broj: {broj}&lt;/p&gt;\n      &lt;button onClick={() =&gt; postaviBroj(broj + 1)}&gt;Pove\u0107aj&lt;/button&gt;\n      &lt;button onClick={() =&gt; postaviBroj(broj - 1)}&gt;Smanji&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre> <p>Kori\u0161tenje state-a u klasnim komponentama:</p> <pre><code>class BrojacKlasa extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { broj: 0 };\n  }\n\n  povecajBroj = () =&gt; {\n    this.setState({ broj: this.state.broj + 1 });\n  }\n\n  smanjiBroj = () =&gt; {\n    this.setState({ broj: this.state.broj - 1 });\n  }\n\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;p&gt;Trenutni broj: {this.state.broj}&lt;/p&gt;\n        &lt;button onClick={this.povecajBroj}&gt;Pove\u0107aj&lt;/button&gt;\n        &lt;button onClick={this.smanjiBroj}&gt;Smanji&lt;/button&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n</code></pre>"},{"location":"content/react-library/#lifecycle-metode-klasne-komponente","title":"Lifecycle Metode (Klasne komponente)","text":"<p>Klasne komponente imaju niz ugra\u0111enih metoda koje se pozivaju u razli\u010ditim fazama \u017eivotnog ciklusa komponente. Neke od najva\u017enijih su:</p> <ul> <li><code>constructor()</code>: Poziva se prije nego \u0161to se komponenta montira. Koristi se za inicijalizaciju state-a i vezivanje metoda.</li> <li><code>render()</code>: Jedina obavezna metoda. Vra\u0107a React elemente.</li> <li><code>componentDidMount()</code>: Poziva se odmah nakon \u0161to se komponenta montira (ubaci u DOM). Idealno mjesto za dohva\u0107anje podataka s API-ja.</li> <li><code>componentDidUpdate(prevProps, prevState)</code>: Poziva se odmah nakon \u0161to do\u0111e do a\u017euriranja (promjena props-a ili state-a). Nije pozvana pri inicijalnom renderiranju.</li> <li><code>componentWillUnmount()</code>: Poziva se neposredno prije nego \u0161to se komponenta demontira i uni\u0161ti. Koristi se za \u010di\u0161\u0107enje resursa (npr. otkazivanje tajmera, uklanjanje event listenera).</li> </ul> <p>U funkcionalnim komponentama, ekvivalenti lifecycle metoda posti\u017eu se pomo\u0107u <code>useEffect</code> Hook-a.</p>"},{"location":"content/react-library/#event-handling","title":"Event Handling","text":"<p>React ima vlastiti sistem za obradu doga\u0111aja koji je sli\u010dan HTML DOM doga\u0111ajima, ali s nekoliko sintaksnih razlika (npr. <code>onClick</code> umjesto <code>onclick</code>, doga\u0111aji se pi\u0161u camelCase).</p> <pre><code>function GumbZaKlik() {\n  function handleClick() {\n    alert('Gumb je kliknut!');\n  }\n\n  return (\n    &lt;button onClick={handleClick}&gt;\n      Klikni me\n    &lt;/button&gt;\n  );\n}\n</code></pre>"},{"location":"content/react-library/#conditional-rendering","title":"Conditional Rendering","text":"<p>Omogu\u0107ava prikazivanje razli\u010ditih komponenata ili elemenata ovisno o odre\u0111enim uvjetima. To se mo\u017ee posti\u0107i kori\u0161tenjem standardnih JavaScript uvjeta poput <code>if</code> naredbi, ternarnog operatora ili logi\u010dkog <code>&amp;&amp;</code> operatora.</p> <p>Kori\u0161tenje <code>if</code> naredbe:</p> <pre><code>function PozdravKorisniku(props) {\n  const isLoggedIn = props.isLoggedIn;\n  if (isLoggedIn) {\n    return &lt;h1&gt;Dobrodo\u0161li natrag!&lt;/h1&gt;;\n  }\n  return &lt;h1&gt;Molimo prijavite se.&lt;/h1&gt;;\n}\n</code></pre> <p>Kori\u0161tenje ternarnog operatora:</p> <pre><code>function PorukaStatusa(props) {\n  const jeOnline = props.jeOnline;\n  return (\n    &lt;p&gt;Korisnik je {jeOnline ? 'online' : 'offline'}.&lt;/p&gt;\n  );\n}\n</code></pre> <p>Kori\u0161tenje logi\u010dkog <code>&amp;&amp;</code> operatora (inline if):</p> <pre><code>function PrikaziObavijesti(props) {\n  const neprocitanePoruke = props.neprocitanePoruke;\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Zdravo!&lt;/h1&gt;\n      {neprocitanePoruke.length &gt; 0 &amp;&amp;\n        &lt;h2&gt;\n          Imate {neprocitanePoruke.length} nepro\u010ditanih poruka.\n        &lt;/h2&gt;\n      }\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"content/react-library/#liste-i-kljucevi","title":"Liste i klju\u010devi","text":"<p>Za prikazivanje listi elemenata u React-u, obi\u010dno se koristi JavaScript <code>map()</code> funkcija. Svaki element liste mora imati jedinstveni <code>key</code> prop. Klju\u010devi poma\u017eu React-u da identificira koji su se itemi promijenili, dodali ili uklonili, \u0161to je va\u017eno za efikasno a\u017euriranje DOM-a.</p> <p><pre><code>function ListaStavki(props) {\n  const brojevi = props.brojevi;\n  const listaElemenata = brojevi.map((broj) =&gt;\n    &lt;li key={broj.toString()}&gt;\n      {broj}\n    &lt;/li&gt;\n  );\n  return (\n    &lt;ul&gt;{listaElemenata}&lt;/ul&gt;\n  );\n}\n\nconst brojevi = [1, 2, 3, 4, 5];\n// &lt;ListaStavki brojevi={brojevi} /&gt;\n</code></pre> Klju\u010devi trebaju biti stabilni, predvidljivi i jedinstveni me\u0111u sibling elementima. Kori\u0161tenje indeksa kao klju\u010deva se ne preporu\u010duje ako se redoslijed itema mo\u017ee promijeniti.</p>"},{"location":"content/react-library/#komunikacija-izmeu-komponenata-i-kompozicija","title":"Komunikacija izme\u0111u komponenata i Kompozicija","text":"<p>Efikasna komunikacija i kompozicija komponenata su sr\u017e izgradnje slo\u017eenih React aplikacija.</p>"},{"location":"content/react-library/#komunikacija-roditelj-dijete-parent-to-child","title":"Komunikacija Roditelj-Dijete (Parent-to-Child)","text":"<p>Naj\u010de\u0161\u0107i na\u010din komunikacije. Roditeljska komponenta proslje\u0111uje podatke dje\u010djoj komponenti putem <code>props</code>.</p> <pre><code>// Roditeljska komponenta\nfunction ProfilKorisnika() {\n  const korisnik = { ime: 'Pero Peri\u0107', godine: 30 };\n  return &lt;DetaljiKorisnika korisnik={korisnik} /&gt;;\n}\n\n// Dje\u010dja komponenta\nfunction DetaljiKorisnika(props) {\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Ime: {props.korisnik.ime}&lt;/p&gt;\n      &lt;p&gt;Godine: {props.korisnik.godine}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"content/react-library/#komunikacija-dijete-roditelj-child-to-parent","title":"Komunikacija Dijete-Roditelj (Child-to-Parent)","text":"<p>Dje\u010dja komponenta mo\u017ee komunicirati s roditeljskom komponentom proslje\u0111ivanjem callback funkcije kao prop. Kada se u dje\u010djoj komponenti dogodi neki doga\u0111aj, ona poziva tu callback funkciju, proslje\u0111uju\u0107i podatke roditelju.</p> <pre><code>// Roditeljska komponenta\nfunction KontrolnaPloca() {\n  const [poruka, postaviPoruku] = useState('');\n\n  function obradiPodatkeIzDjeteta(podaci) {\n    postaviPoruku(`Podaci iz djeteta: ${podaci}`);\n  }\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;{poruka}&lt;/p&gt;\n      &lt;DjecjaKomponenta posaljiPodatkeRoditelju={obradiPodatkeIzDjeteta} /&gt;\n    &lt;/div&gt;\n  );\n}\n\n// Dje\u010dja komponenta\nfunction DjecjaKomponenta(props) {\n  const [unos, postaviUnos] = useState('');\n\n  function handleChange(event) {\n    postaviUnos(event.target.value);\n  }\n\n  function handleSubmit() {\n    props.posaljiPodatkeRoditelju(unos); // Poziv callback funkcije\n  }\n\n  return (\n    &lt;div&gt;\n      &lt;input type=\"text\" value={unos} onChange={handleChange} /&gt;\n      &lt;button onClick={handleSubmit}&gt;Po\u0161alji podatke roditelju&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"content/react-library/#komunikacija-izmeu-sibling-komponenata","title":"Komunikacija izme\u0111u Sibling Komponenata","text":"<p>Sibling komponente (komponente na istom nivou hijerarhije) ne mogu direktno komunicirati. Komunikacija se obi\u010dno odvija podizanjem state-a (<code>lifting state up</code>) na najbli\u017eeg zajedni\u010dkog roditelja. Taj roditelj onda proslje\u0111uje podatke i callback funkcije sibling komponentama putem props-a.</p> <pre><code>// Roditeljska komponenta (zajedni\u010dki predak)\nfunction App() {\n  const [vrijednost, postaviVrijednost] = useState('');\n\n  function handlePrviSiblingPromjenu(novaVrijednost) {\n    postaviVrijednost(novaVrijednost);\n  }\n\n  function handleDrugiSiblingPromjenu(novaVrijednost) {\n    postaviVrijednost(novaVrijednost);\n  }\n\n  return (\n    &lt;div&gt;\n      &lt;PrviSibling vrijednost={vrijednost} onPromjena={handlePrviSiblingPromjenu} /&gt;\n      &lt;DrugiSibling vrijednost={vrijednost} onPromjena={handleDrugiSiblingPromjenu} /&gt;\n      &lt;p&gt;Trenutna zajedni\u010dka vrijednost: {vrijednost}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\n// Prva Sibling komponenta\nfunction PrviSibling(props) {\n  function handleChange(event) {\n    props.onPromjena(event.target.value);\n  }\n  return &lt;input type=\"text\" value={props.vrijednost} onChange={handleChange} placeholder=\"Prvi Sibling Unos\" /&gt;;\n}\n\n// Druga Sibling komponenta\nfunction DrugiSibling(props) {\n    function handleChange(event) {\n    props.onPromjena(event.target.value);\n  }\n  return &lt;input type=\"text\" value={props.vrijednost} onChange={handleChange} placeholder=\"Drugi Sibling Unos\" /&gt;;\n}\n</code></pre> <p>Za slo\u017eenije scenarije komunikacije, posebno u ve\u0107im aplikacijama, koriste se alati za upravljanje stanjem poput Context API-ja ili biblioteka kao \u0161to su Redux ili Zustand.</p>"},{"location":"content/react-library/#kompozicija-komponenata","title":"Kompozicija Komponenata","text":"<p>React poti\u010de kompoziciju, gdje se komponente grade od drugih manjih, specijaliziranih komponenata. Ovo dovodi do modularnijeg, lak\u0161eg za odr\u017eavanje i ponovno upotreblivog koda.</p> <p>Containment (Zadr\u017eavanje):</p> <p>Neke komponente ne znaju unaprijed svoju djecu. Takve komponente mogu koristiti <code>props.children</code> da bi prikazale elemente koji su im proslije\u0111eni kao djeca.</p> <pre><code>function Okvir(props) {\n  return (\n    &lt;div className={'okvir okvir-' + props.boja}&gt;\n      {props.children} {/* Ovdje \u0107e se renderirati dje\u010dji elementi */}\n    &lt;/div&gt;\n  );\n}\n\nfunction DobrodoslicaDialog() {\n  return (\n    &lt;Okvir boja=\"plava\"&gt;\n      &lt;h1 className=\"dialog-naslov\"&gt;Dobrodo\u0161li&lt;/h1&gt;\n      &lt;p className=\"dialog-poruka\"&gt;\n        Hvala \u0161to ste posjetili na\u0161u aplikaciju!\n      &lt;/p&gt;\n    &lt;/Okvir&gt;\n  );\n}\n</code></pre> <p>Specijalizacija:</p> <p>Ponekad se komponente mogu smatrati \"specijalnim slu\u010dajevima\" op\u0107enitijih komponenata. To se mo\u017ee posti\u0107i konfiguriranjem op\u0107enitije komponente putem props-a.</p> <p><pre><code>function Dialog(props) {\n  return (\n    &lt;div className=\"dialog\"&gt;\n      &lt;h1 className=\"dialog-naslov\"&gt;{props.naslov}&lt;/h1&gt;\n      &lt;p className=\"dialog-poruka\"&gt;{props.poruka}&lt;/p&gt;\n      {props.children}\n    &lt;/div&gt;\n  );\n}\n\nfunction UpozorenjeDialog() {\n  return (\n    &lt;Dialog\n      naslov=\"Upozorenje!\"\n      poruka=\"Jeste li sigurni da \u017eelite nastaviti?\"\n    /&gt;\n  );\n}\n\nfunction UspjehDialog(props) {\n  return (\n    &lt;Dialog\n      naslov=\"Uspjeh!\"\n      poruka={props.porukaUspjeha}\n    /&gt;\n  );\n}\n</code></pre> Ovdje <code>UpozorenjeDialog</code> i <code>UspjehDialog</code> specijaliziraju op\u0107enitiju <code>Dialog</code> komponentu.</p>"},{"location":"content/react-library/#react-hooks-osnove","title":"React Hooks (Osnove)","text":"<p>Hookovi su funkcije koje omogu\u0107avaju \"ka\u010denje\" na React state i lifecycle zna\u010dajke iz funkcionalnih komponenata. Uvedeni su u Reactu 16.8 i predstavljaju moderniji na\u010din pisanja React komponenata.</p>"},{"location":"content/react-library/#zasto-hookovi","title":"Za\u0161to Hookovi?","text":"<p>Prije Hookova, state i lifecycle metode bile su dostupne samo u klasnim komponentama. Hookovi rje\u0161avaju nekoliko problema:</p> <ul> <li>Ponavljanje logike state-a: Hookovi omogu\u0107avaju izdvajanje logike state-a u ponovno upotrebljive funkcije (custom hooks).</li> <li>Slo\u017eene komponente: Klasne komponente mogu postati velike i te\u0161ke za razumijevanje zbog mije\u0161anja logike u lifecycle metodama. Hookovi omogu\u0107avaju organiziranje logike po srodnim dijelovima.</li> <li>Klase mogu biti zbunjuju\u0107e: <code>this</code> keyword, vezivanje metoda i op\u0107enito ES6 klase mogu biti prepreka za u\u010denje Reacta.</li> </ul>"},{"location":"content/react-library/#osnovni-hookovi","title":"Osnovni Hookovi","text":""},{"location":"content/react-library/#usestate","title":"\u25b8 <code>useState</code>","text":"<p>Omogu\u0107ava dodavanje lokalnog state-a funkcionalnim komponentama.</p> <ul> <li>Sintaksa: <code>const [state, setState] = useState(initialState);</code></li> <li>Prima inicijalno stanje kao argument.</li> <li>Vra\u0107a niz sa dvije vrijednosti: trenutno stanje i funkciju za a\u017euriranje tog stanja.</li> </ul> <pre><code>import React, { useState } from 'react';\n\nfunction Prekidac() {\n  const [jeUkljucen, postaviUkljucenost] = useState(false);\n\n  return (\n    &lt;button onClick={() =&gt; postaviUkljucenost(!jeUkljucen)}&gt;\n      {jeUkljucen ? 'UKLJU\u010cENO' : 'ISKLJU\u010cENO'}\n    &lt;/button&gt;\n  );\n}\n</code></pre>"},{"location":"content/react-library/#useeffect","title":"\u25b8 <code>useEffect</code>","text":"<p>Omogu\u0107ava izvr\u0161avanje side effecta u funkcionalnim komponentama. Side effecti uklju\u010duju dohva\u0107anje podataka, postavljanje pretplata, ru\u010dno mijenjanje DOM-a, itd. <code>useEffect</code> je zamjena za <code>componentDidMount</code>, <code>componentDidUpdate</code>, i <code>componentWillUnmount</code> iz klasnih komponenata.</p> <ul> <li>Sintaksa: <code>useEffect(() =&gt; { /* side effect logika */ return () =&gt; { /* cleanup logika */ }; }, [dependencies]);</code></li> <li>Prima funkciju koja sadr\u017ei side effect logiku.</li> <li>Opcionalno, mo\u017ee vratiti cleanup funkciju koja se izvr\u0161ava prije nego \u0161to se komponenta demontira ili prije sljede\u0107eg izvr\u0161avanja effecta.</li> <li>Opcionalno, prima niz zavisnosti (<code>dependencies</code>). Effect \u0107e se ponovno izvr\u0161iti samo ako se neka od zavisnosti promijeni.<ul> <li>Ako je niz zavisnosti prazan (<code>[]</code>), effect se izvr\u0161ava samo jednom nakon inicijalnog renderiranja (kao <code>componentDidMount</code>).</li> <li>Ako niz zavisnosti nije specificiran, effect se izvr\u0161ava nakon svakog renderiranja.</li> </ul> </li> </ul> <p>Primjer: Dohva\u0107anje podataka</p> <pre><code>import React, { useState, useEffect } from 'react';\n\nfunction PodaciKorisnika({ korisnikId }) {\n  const [korisnik, postaviKorisnika] = useState(null);\n  const [loading, postaviLoading] = useState(true);\n\n  useEffect(() =&gt; {\n    postaviLoading(true);\n    fetch(\\`https://api.example.com/users/\\${korisnikId}\\`)\n      .then(response =&gt; response.json())\n      .then(data =&gt; {\n        postaviKorisnika(data);\n        postaviLoading(false);\n      })\n      .catch(error =&gt; {\n        console.error(\"Gre\u0161ka pri dohva\u0107anju korisnika:\", error);\n        postaviLoading(false);\n      });\n\n    // Cleanup funkcija nije uvijek potrebna, ali je dobra praksa za npr. otkazivanje fetch-a\n    return () =&gt; {\n      // Ovdje bi se mogla otkazati fetch operacija ako je komponenta demontirana prije nego \u0161to zavr\u0161i\n    };\n  }, [korisnikId]); // Effect se ponovno izvr\u0161ava ako se korisnikId promijeni\n\n  if (loading) {\n    return &lt;p&gt;U\u010ditavanje...&lt;/p&gt;;\n  }\n\n  if (!korisnik) {\n    return &lt;p&gt;Korisnik nije prona\u0111en.&lt;/p&gt;;\n  }\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;{korisnik.ime}&lt;/h1&gt;\n      &lt;p&gt;Email: {korisnik.email}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre> <p>Primjer: Postavljanje naslova dokumenta</p> <pre><code>import React, { useState, useEffect } from 'react';\n\nfunction BrojacNaslova() {\n  const [broj, postaviBroj] = useState(0);\n\n  useEffect(() =&gt; {\n    // A\u017eurira naslov dokumenta nakon svakog renderiranja\n    document.title = \\`Kliknuli ste \\${broj} puta\\`;\n  }, [broj]); // Ponovno izvr\u0161i samo ako se 'broj' promijeni\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Kliknuli ste {broj} puta&lt;/p&gt;\n      &lt;button onClick={() =&gt; postaviBroj(broj + 1)}&gt;\n        Klikni me\n      &lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>"},{"location":"content/react-library/#pravila-hookova","title":"Pravila Hookova","text":"<p>Postoje dva va\u017ena pravila koja se moraju po\u0161tovati prilikom kori\u0161tenja Hookova:</p> <ol> <li>Pozivati Hookove samo na najvi\u0161em nivou: Ne pozivati Hookove unutar petlji, uvjeta ili ugnije\u017edenih funkcija. Uvijek ih pozivati na vrhu va\u0161e React funkcionalne komponente, prije bilo kakvog <code>return</code> statementa.</li> <li>Pozivati Hookove samo iz React funkcija: Ne pozivati Hookove iz obi\u010dnih JavaScript funkcija. Pozivati ih samo iz React funkcionalnih komponenata ili iz custom Hookova.</li> </ol> <p>Linter pluginovi (poput <code>eslint-plugin-react-hooks</code>) poma\u017eu u automatskom provo\u0111enju ovih pravila.</p>"},{"location":"content/react-library/#custom-hookovi","title":"Custom Hookovi","text":"<p>Custom Hookovi su JavaScript funkcije \u010dije ime po\u010dinje sa <code>use</code> i koje mogu pozivati druge Hookove. Omogu\u0107avaju izdvajanje logike komponenata u ponovno upotrebljive funkcije.</p> <p>Primjer: Custom Hook za pra\u0107enje \u0161irine prozora</p> <p><pre><code>import { useState, useEffect } from 'react';\n\nfunction useSirinaProzora() {\n  const [sirina, postaviSirinu] = useState(window.innerWidth);\n\n  useEffect(() =&gt; {\n    function handleResize() {\n      postaviSirinu(window.innerWidth);\n    }\n\n    window.addEventListener('resize', handleResize);\n\n    // Cleanup funkcija za uklanjanje event listenera\n    return () =&gt; {\n      window.removeEventListener('resize', handleResize);\n    };\n  }, []); // Prazan niz zavisnosti, izvr\u0161ava se samo pri montiranju i demontiranju\n\n  return sirina;\n}\n\n// Kori\u0161tenje custom Hook-a u komponenti\nfunction MojaKomponenta() {\n  const sirinaProzora = useSirinaProzora();\n\n  return &lt;p&gt;\u0160irina prozora je: {sirinaProzora}px&lt;/p&gt;;\n}\n</code></pre> Custom Hookovi su mo\u0107an alat za dijeljenje logike izme\u0111u komponenata bez potrebe za render props ili higher-order components (HOC).</p>"},{"location":"content/react-library/#stiliziranje-u-react-u","title":"Stiliziranje u React-u","text":"<p>Postoji vi\u0161e na\u010dina za stiliziranje React komponenata. Izbor ovisi o veli\u010dini projekta, preferencijama tima i specifi\u010dnim potrebama.</p>"},{"location":"content/react-library/#1-inline-styles","title":"1. Inline Styles","text":"<p>Stilovi se mogu primijeniti direktno na elemente koriste\u0107i <code>style</code> atribut. Vrijednost <code>style</code> atributa mora biti JavaScript objekt, gdje su klju\u010devi camelCase verzije CSS svojstava, a vrijednosti su stringovi (ili brojevi za neka svojstva).</p> <pre><code>function MojStiliziraniTekst() {\n  const stilNaslova = {\n    color: 'blue',\n    fontSize: '24px', // '24px' umjesto samo 24\n    paddingLeft: '10px',\n    backgroundColor: '#f0f0f0'\n  };\n\n  return &lt;h1 style={stilNaslova}&gt;Ovo je stilizirani naslov&lt;/h1&gt;;\n}\n</code></pre> <p>Prednosti: - Jednostavno za brze, dinami\u010dke stilove. - Enkapsulacija stila unutar komponente.</p> <p>Nedostaci: - Ograni\u010dene CSS mogu\u0107nosti (nema pseudo-klasa, media query-ja direktno). - Mo\u017ee postati nepregledno za ve\u0107i broj stilova. - Performanse mogu biti lo\u0161ije u nekim slu\u010dajevima u usporedbi s CSS datotekama.</p>"},{"location":"content/react-library/#2-obicne-css-datoteke","title":"2. Obi\u010dne CSS datoteke","text":"<p>Najtradicionalniji pristup. Kreirate <code>.css</code> datoteku i importirate je u svoju komponentu (ili globalno u <code>index.js</code> ili <code>App.js</code>).</p> <p><code>stilovi.css</code>: <pre><code>.card {\n  border: 1px solid #ccc;\n  padding: 16px;\n  margin: 8px;\n  border-radius: 4px;\n  box-shadow: 2px 2px 5px rgba(0,0,0,0.1);\n}\n\n.card-title {\n  font-size: 1.5em;\n  color: #333;\n}\n</code></pre></p> <p><code>MojaKartica.js</code>: <pre><code>import React from 'react';\nimport './stilovi.css'; // Importiranje CSS datoteke\n\nfunction MojaKartica(props) {\n  return (\n    &lt;div className=\"card\"&gt;\n      &lt;h2 className=\"card-title\"&gt;{props.naslov}&lt;/h2&gt;\n      &lt;p&gt;{props.sadrzaj}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default MojaKartica;\n</code></pre></p> <p>Prednosti: - Poznat pristup. - Puna podr\u0161ka za sve CSS zna\u010dajke. - CSS mo\u017ee biti ke\u0161iran od strane preglednika.</p> <p>Nedostaci: - Globalni scope CSS klasa mo\u017ee dovesti do konflikata imena (npr. ako dvije razli\u010dite komponente koriste istu klasu <code>.button</code>). - Te\u017ee je pratiti koji stilovi utje\u010du na koju komponentu u velikim aplikacijama.</p>"},{"location":"content/react-library/#3-css-moduli","title":"3. CSS Moduli","text":"<p>CSS Moduli rje\u0161avaju problem globalnog scope-a CSS klasa tako \u0161to lokaliziraju klase na nivou komponente. Kada importirate CSS datoteku kao modul (npr. <code>stilovi.module.css</code>), React (ili alat za build poput Webpacka ili Vitea) automatski generira jedinstvena imena klasa.</p> <p><code>MojaTipka.module.css</code>: <pre><code>.tipka { /* Originalno ime klase */\n  background-color: dodgerblue;\n  color: white;\n  padding: 10px 20px;\n  border: 2px solid palevioletred;\n  border-radius: 5px;\n  cursor: pointer;\n}\n\n.tipka:hover {\n  background-color: royalblue;\n}\n</code></pre></p> <p><code>MojaTipka.js</code>: <pre><code>import React from 'react';\nimport stilovi from './MojaTipka.module.css'; // Importiranje kao modul\n\nfunction MojaTipka(props) {\n  // stilovi.tipka \u0107e imati generirano jedinstveno ime, npr. 'MojaTipka_tipka__aBcDe'\n  return (\n    &lt;button className={stilovi.tipka}&gt;\n      {props.children}\n    &lt;/button&gt;\n  );\n}\n\nexport default MojaTipka;\n</code></pre></p> <p>Prednosti: - Lokalni scope klasa, izbjegavaju se konflikti. - Jasna veza izme\u0111u komponente i njenih stilova. - Mogu\u0107nost kori\u0161tenja istih imena klasa u razli\u010ditim modulima bez problema.</p> <p>Nedostaci: - Zahtijeva specifi\u010dno imenovanje datoteka (<code>.module.css</code>). - Mo\u017ee biti malo te\u017ee dijeliti stilove izme\u0111u komponenata ako nije planirano.</p>"},{"location":"content/react-library/#4-css-in-js-biblioteke","title":"4. CSS-in-JS Biblioteke","text":"<p>Ove biblioteke omogu\u0107avaju pisanje CSS-a direktno unutar JavaScript koda koriste\u0107i template literals ili objekte. Popularne biblioteke uklju\u010duju:</p> <ul> <li>Styled Components: Koristi tagged template literals za definiranje stiliziranih komponenata.</li> <li>Emotion: Sli\u010dan Styled Components, ali nudi i druge na\u010dine definiranja stilova (npr. <code>css</code> prop).</li> <li>JSS (JavaScript Style Sheets): Koristi JavaScript objekte za definiranje stilova.</li> </ul> <p>Primjer sa Styled Components:</p> <p>Prvo, instalirajte biblioteku: <code>npm install styled-components</code> ili <code>yarn add styled-components</code>.</p> <pre><code>import React from 'react';\nimport styled from 'styled-components';\n\n// Kreiranje stilizirane komponente &lt;Tipka&gt;\nconst Tipka = styled.button\\`\n  background-color: palevioletred;\n  color: white;\n  font-size: 1em;\n  margin: 1em;\n  padding: 0.25em 1em;\n  border: 2px solid palevioletred;\n  border-radius: 3px;\n\n  &amp;:hover {\n    background-color: mediumvioletred;\n  }\n\n  // Stilovi se mogu bazirati na props-ima\n  ${props =&gt; props.primary &amp;&amp; \\`\n    background-color: white;\n    color: palevioletred;\n  \\`}\n\\`;\n\nfunction App() {\n  return (\n    &lt;div&gt;\n      &lt;Tipka&gt;Obi\u010dna Tipka&lt;/Tipka&gt;\n      &lt;Tipka primary&gt;Primarna Tipka&lt;/Tipka&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default App;\n</code></pre> <p>Prednosti: - Komponentno orijentirani stilovi. - Dinami\u010dko stiliziranje bazirano na props-ima je jednostavno. - Automatsko prefiksiranje vendor prefiksa. - Nema problema s konfliktima imena klasa. - Mogu\u0107nost kreiranja tema.</p> <p>Nedostaci: - Dodatna biblioteka (pove\u0107ava veli\u010dinu bundle-a). - Mo\u017ee postojati blagi overhead u performansama (iako je obi\u010dno zanemariv). - Sintaksa mo\u017ee biti nova za neke developere.</p>"},{"location":"content/react-library/#5-utility-first-css-frameworks-npr-tailwind-css","title":"5. Utility-First CSS Frameworks (npr. Tailwind CSS)","text":"<p>Tailwind CSS je popularan framework koji pru\u017ea skup nisko-razinskih utility klasa koje se mogu direktno primijeniti u HTML-u (ili JSX-u) za izgradnju korisni\u010dkog interfejsa. Umjesto pisanja prilago\u0111enog CSS-a, kombinirate postoje\u0107e klase.</p> <p>Primjer sa Tailwind CSS:</p> <p>Prvo, potrebno je instalirati i konfigurirati Tailwind CSS u va\u0161em projektu.</p> <pre><code>// Primjer komponente koja koristi Tailwind klase\nfunction TailwindKartica() {\n  return (\n    &lt;div className=\"max-w-sm mx-auto bg-white rounded-xl shadow-md overflow-hidden md:max-w-2xl m-5\"&gt;\n      &lt;div className=\"md:flex\"&gt;\n        &lt;div className=\"md:flex-shrink-0\"&gt;\n          &lt;img className=\"h-48 w-full object-cover md:w-48\" src=\"/img/store.jpg\" alt=\"Trgovina\" /&gt;\n        &lt;/div&gt;\n        &lt;div className=\"p-8\"&gt;\n          &lt;div className=\"uppercase tracking-wide text-sm text-indigo-500 font-semibold\"&gt;Studija slu\u010daja&lt;/div&gt;\n          &lt;a href=\"#\" className=\"block mt-1 text-lg leading-tight font-medium text-black hover:underline\"&gt;Pronala\u017eenje kupaca za va\u0161u tvrtku&lt;/a&gt;\n          &lt;p className=\"mt-2 text-gray-500\"&gt;Po\u010detak s novim poslom mo\u017ee biti te\u017eak. Ovaj vodi\u010d \u0107e vam pomo\u0107i da prona\u0111ete svoje prve kupce.&lt;/p&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre> <p>Prednosti: - Brz razvoj UI-a. - Konzistentan dizajn jer se koriste predefinirane klase. - Nema potrebe za imenovanjem CSS klasa. - CSS bundle je obi\u010dno vrlo mali u produkciji jer se generiraju samo kori\u0161tene klase (uz PurgeCSS/JIT).</p> <p>Nedostaci: - HTML/JSX mo\u017ee postati \"zagu\u0161en\" s mnogo klasa. - Zahtijeva u\u010denje Tailwind klasa. - Manje fleksibilno za vrlo specifi\u010dne ili jedinstvene dizajne bez dodatnog prilago\u0111avanja.</p>"},{"location":"content/react-library/#koji-pristup-odabrati","title":"Koji pristup odabrati?","text":"<ul> <li>Za male projekte ili brze prototipove, inline stilovi ili obi\u010dne CSS datoteke mogu biti dovoljni.</li> <li>Za srednje do velike projekte gdje je va\u017ena modularnost i izbjegavanje konflikata, CSS Moduli ili CSS-in-JS biblioteke su dobar izbor.</li> <li>Ako preferirate utility-first pristup i brzu izgradnju UI-a s konzistentnim dizajnom, Tailwind CSS je odli\u010dna opcija.</li> </ul> <p>\u010cesto se u projektima koristi kombinacija pristupa. Na primjer, globalni stilovi i teme mogu biti definirani u obi\u010dnim CSS datotekama, dok se specifi\u010dni stilovi komponenata rje\u0161avaju pomo\u0107u CSS Modula ili CSS-in-JS.</p>"},{"location":"content/react-library/#rad-sa-formama","title":"Rad sa Formama","text":"<p>Forme su klju\u010dni dio ve\u0107ine web aplikacija za prikupljanje korisni\u010dkog unosa. React pru\u017ea kontroliran na\u010din za rad s formama.</p>"},{"location":"content/react-library/#kontrolirane-komponente-controlled-components","title":"Kontrolirane Komponente (Controlled Components)","text":"<p>U HTML-u, elementi forme poput <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code>, i <code>&lt;select&gt;</code> obi\u010dno odr\u017eavaju vlastito stanje i a\u017euriraju ga na temelju korisni\u010dkog unosa. U Reactu, kontrolirane komponente su one gdje React stanje (obi\u010dno u state-u komponente) postaje \"jedini izvor istine\" za vrijednost input polja.</p> <p>To zna\u010di da: 1. Vrijednost input polja se postavlja iz React state-a. 2. Svaka promjena u input polju (npr. kucanje korisnika) pokre\u0107e funkciju koja a\u017eurira React state.</p> <pre><code>import React, { useState } from 'react';\n\nfunction FormaImena() {\n  const [ime, postaviIme] = useState(''); // 1. State za \u010duvanje vrijednosti inputa\n\n  function handleChange(event) {\n    postaviIme(event.target.value); // 2. A\u017euriranje state-a pri svakoj promjeni\n  }\n\n  function handleSubmit(event) {\n    alert('Poslano ime: ' + ime);\n    event.preventDefault(); // Sprje\u010dava defaultno pona\u0161anje forme (reload stranice)\n  }\n\n  return (\n    &lt;form onSubmit={handleSubmit}&gt;\n      &lt;label&gt;\n        Ime:\n        &lt;input type=\"text\" value={ime} onChange={handleChange} /&gt; {/* Vrijednost inputa je vezana za state */}\n      &lt;/label&gt;\n      &lt;button type=\"submit\"&gt;Po\u0161alji&lt;/button&gt;\n    &lt;/form&gt;\n  );\n}\n\nexport default FormaImena;\n</code></pre> <p>Prednosti kontroliranih komponenata: - Vrijednost inputa je uvijek sinkronizirana s React state-om. - Omogu\u0107ava laku validaciju i manipulaciju unosa. - Lak\u0161e je implementirati dinami\u010dke forme.</p>"},{"location":"content/react-library/#razliciti-tipovi-inputa","title":"Razli\u010diti Tipovi Inputa","text":""},{"location":"content/react-library/#textarea","title":"\u25b8 <code>textarea</code>","text":"<p>U HTML-u, <code>&lt;textarea&gt;</code> vrijednost se postavlja unutar taga: <code>&lt;textarea&gt;Neki tekst&lt;/textarea&gt;</code>. U Reactu, <code>&lt;textarea&gt;</code> koristi <code>value</code> atribut, sli\u010dno kao <code>&lt;input type=\"text\"&gt;</code>.</p> <pre><code>function FormaKomentara() {\n  const [komentar, postaviKomentar] = useState('');\n\n  function handleChange(event) {\n    postaviKomentar(event.target.value);\n  }\n\n  return (\n    &lt;form&gt;\n      &lt;label&gt;\n        Komentar:\n        &lt;textarea value={komentar} onChange={handleChange} /&gt;\n      &lt;/label&gt;\n      &lt;p&gt;Va\u0161 komentar: {komentar}&lt;/p&gt;\n    &lt;/form&gt;\n  );\n}\n</code></pre>"},{"location":"content/react-library/#select-dropdown","title":"\u25b8 <code>select</code> (Dropdown)","text":"<p>U HTML-u, odabrana vrijednost <code>&lt;select&gt;</code> taga se ozna\u010dava <code>selected</code> atributom na <code>&lt;option&gt;</code> elementu. U Reactu, <code>value</code> atribut se postavlja na samom <code>select</code> tagu.</p> <p><pre><code>function FormaOdabiraVoca() {\n  const [odabranoVoce, postaviOdabranoVoce] = useState('kokos'); // Inicijalna vrijednost\n\n  function handleChange(event) {\n    postaviOdabranoVoce(event.target.value);\n  }\n\n  function handleSubmit(event) {\n    alert('Va\u0161e omiljeno vo\u0107e je: ' + odabranoVoce);\n    event.preventDefault();\n  }\n\n  return (\n    &lt;form onSubmit={handleSubmit}&gt;\n      &lt;label&gt;\n        Odaberite omiljeno vo\u0107e:\n        &lt;select value={odabranoVoce} onChange={handleChange}&gt;\n          &lt;option value=\"grejpfrut\"&gt;Grejpfrut&lt;/option&gt;\n          &lt;option value=\"limeta\"&gt;Limeta&lt;/option&gt;\n          &lt;option value=\"kokos\"&gt;Kokos&lt;/option&gt;\n          &lt;option value=\"mango\"&gt;Mango&lt;/option&gt;\n        &lt;/select&gt;\n      &lt;/label&gt;\n      &lt;button type=\"submit\"&gt;Po\u0161alji&lt;/button&gt;\n    &lt;/form&gt;\n  );\n}\n</code></pre> Za <code>multiple</code> select, <code>value</code> atribut na <code>select</code> tagu mo\u017ee primiti niz vrijednosti: <code>&lt;select multiple={true} value={['B', 'C']}&gt;</code>.</p>"},{"location":"content/react-library/#rukovanje-s-vise-inputa","title":"Rukovanje s Vi\u0161e Inputa","text":"<p>Kada imate vi\u0161e input polja, mo\u017eete koristiti <code>name</code> atribut na svakom inputu i jednu <code>handleChange</code> funkciju za sve njih.</p> <p><pre><code>import React, { useState } from 'react';\n\nfunction Rezervacija() {\n  const [unosi, postaviUnose] = useState({\n    imeGosta: '',\n    brojGostiju: 1,\n    dolaziNaVeceru: true\n  });\n\n  function handleInputChange(event) {\n    const target = event.target;\n    const vrijednost = target.type === 'checkbox' ? target.checked : target.value;\n    const ime = target.name;\n\n    postaviUnose(stariUnosi =&gt; ({\n      ...stariUnosi, // Kopiraj sve stare vrijednosti\n      [ime]: vrijednost // A\u017euriraj samo promijenjenu vrijednost\n    }));\n  }\n\n  function handleSubmit(event) {\n    alert(\\`Ime: \\${unosi.imeGosta}, Broj gostiju: \\${unosi.brojGostiju}, Dolazi na ve\u010deru: \\${unosi.dolaziNaVeceru}\\`);\n    event.preventDefault();\n  }\n\n  return (\n    &lt;form onSubmit={handleSubmit}&gt;\n      &lt;label&gt;\n        Ime gosta:\n        &lt;input\n          name=\"imeGosta\"\n          type=\"text\"\n          value={unosi.imeGosta}\n          onChange={handleInputChange} /&gt;\n      &lt;/label&gt;\n      &lt;br /&gt;\n      &lt;label&gt;\n        Broj gostiju:\n        &lt;input\n          name=\"brojGostiju\"\n          type=\"number\"\n          value={unosi.brojGostiju}\n          onChange={handleInputChange} /&gt;\n      &lt;/label&gt;\n      &lt;br /&gt;\n      &lt;label&gt;\n        Dolazi na ve\u010deru:\n        &lt;input\n          name=\"dolaziNaVeceru\"\n          type=\"checkbox\"\n          checked={unosi.dolaziNaVeceru}\n          onChange={handleInputChange} /&gt;\n      &lt;/label&gt;\n      &lt;br /&gt;\n      &lt;button type=\"submit\"&gt;Po\u0161alji&lt;/button&gt;\n    &lt;/form&gt;\n  );\n}\n\nexport default Rezervacija;\n</code></pre> Kori\u0161tenje computed property names <code>[ime]: vrijednost</code> omogu\u0107ava dinami\u010dko postavljanje klju\u010da u objektu state-a.</p>"},{"location":"content/react-library/#validacija-unosa","title":"Validacija Unosa","text":"<p>Validacija se mo\u017ee obaviti unutar <code>handleChange</code> funkcije ili prilikom submita forme.</p> <p>Primjer: Jednostavna validacija prilikom submita</p> <pre><code>function FormaPrijave() {\n  const [email, postaviEmail] = useState('');\n  const [lozinka, postaviLozinku] = useState('');\n  const [greske, postaviGreske] = useState({});\n\n  function handleSubmit(event) {\n    event.preventDefault();\n    const noveGreske = {};\n\n    if (!email) {\n      noveGreske.email = 'Email je obavezan.';\n    } else if (!/\\\\S+@\\\\S+\\\\.\\\\S+/.test(email)) {\n      noveGreske.email = 'Email nije validan.';\n    }\n\n    if (!lozinka) {\n      noveGreske.lozinka = 'Lozinka je obavezna.';\n    } else if (lozinka.length &lt; 6) {\n      noveGreske.lozinka = 'Lozinka mora imati najmanje 6 znakova.';\n    }\n\n    postaviGreske(noveGreske);\n\n    if (Object.keys(noveGreske).length === 0) {\n      // Nema gre\u0161aka, po\u0161alji podatke\n      alert('Prijava uspje\u0161na!');\n      // Ovdje bi i\u0161la logika slanja podataka na server\n    }\n  }\n\n  return (\n    &lt;form onSubmit={handleSubmit}&gt;\n      &lt;div&gt;\n        &lt;label&gt;Email:&lt;/label&gt;\n        &lt;input type=\"email\" value={email} onChange={e =&gt; postaviEmail(e.target.value)} /&gt;\n        {greske.email &amp;&amp; &lt;p style={{ color: 'red' }}&gt;{greske.email}&lt;/p&gt;}\n      &lt;/div&gt;\n      &lt;div&gt;\n        &lt;label&gt;Lozinka:&lt;/label&gt;\n        &lt;input type=\"password\" value={lozinka} onChange={e =&gt; postaviLozinku(e.target.value)} /&gt;\n        {greske.lozinka &amp;&amp; &lt;p style={{ color: 'red' }}&gt;{greske.lozinka}&lt;/p&gt;}\n      &lt;/div&gt;\n      &lt;button type=\"submit\"&gt;Prijavi se&lt;/button&gt;\n    &lt;/form&gt;\n  );\n}\n</code></pre>"},{"location":"content/react-library/#nekontrolirane-komponente-uncontrolled-components","title":"Nekontrolirane Komponente (Uncontrolled Components)","text":"<p>Alternativa kontroliranim komponentama su nekontrolirane komponente. Kod njih, podaci forme se rukuju direktno od strane DOM-a, a ne React state-a. Da biste dobili vrijednosti iz DOM-a, koristite <code>ref</code>.</p> <p>Iako su kontrolirane komponente preporu\u010deni pristup u ve\u0107ini slu\u010dajeva, nekontrolirane komponente mogu biti korisne: - Kada integrirate React s ne-React kodom. - Za jednostavne forme gdje ne trebate trenutnu vrijednost inputa za validaciju ili dinami\u010dke promjene. - Za upravljanje fokusom, selekcijom teksta ili media playbackom.</p> <p><pre><code>import React, { useRef } from 'react';\n\nfunction NekontroliranaForma() {\n  const inputRef = useRef(null); // Kreiranje ref-a\n\n  function handleSubmit(event) {\n    alert('Poslano ime: ' + inputRef.current.value); // Pristup vrijednosti preko ref.current.value\n    event.preventDefault();\n  }\n\n  return (\n    &lt;form onSubmit={handleSubmit}&gt;\n      &lt;label&gt;\n        Ime:\n        &lt;input type=\"text\" ref={inputRef} /&gt; {/* Povezivanje ref-a s input elementom */}\n      &lt;/label&gt;\n      &lt;button type=\"submit\"&gt;Po\u0161alji&lt;/button&gt;\n    &lt;/form&gt;\n  );\n}\n</code></pre> Za inpute tipa <code>file</code> (<code>&lt;input type=\"file\" /&gt;</code>), oni su uvijek nekontrolirani jer je njihova vrijednost read-only i mo\u017ee biti postavljena samo od strane korisnika.</p>"},{"location":"content/react-library/#biblioteke-za-forme","title":"Biblioteke za Forme","text":"<p>Za slo\u017eenije forme s naprednom validacijom, upravljanjem stanjem forme, i submit logikom, \u010desto se koriste specijalizirane biblioteke poput:</p> <ul> <li>Formik: Popularna biblioteka koja olak\u0161ava rukovanje stanjem forme, validacijom (npr. s Yup-om) i submitom.</li> <li>React Hook Form: Fokusirana na performanse i jednostavnost kori\u0161tenja, oslanja se na Hookove i nekontrolirane komponente (iako podr\u017eava i kontrolirane).</li> <li>React Final Form: Lagana i fleksibilna biblioteka bazirana na Final Form.</li> </ul> <p>Ove biblioteke mogu zna\u010dajno smanjiti koli\u010dinu boilerplate koda potrebnog za kompleksne forme.</p> <p>Ovaj pregled pokriva osnove rada s formama u Reactu. Kontrolirane komponente su temelj, ali va\u017eno je znati i za druge pristupe i alate koji mogu olak\u0161ati razvoj.</p>"},{"location":"content/react-project/","title":"Moodflix \ud83c\udfac","text":"<p>Dobrodo\u0161li u Moodflix, jednostavnu React aplikaciju koja preporu\u010duje filmove na osnovu va\u0161eg trenutnog raspolo\u017eenja.</p> <p>Cilj ove aplikacije je demonstrirati rad sa osnovnim konceptima React-a, poput upravljanja stanjima (<code>useState</code>), efekata (<code>useEffect</code>), komunikacije izme\u0111u komponenti, kao i jednostavne logike za prikaz podataka.</p> <p>Moodflix omogu\u0107ava korisnicima da izaberu svoje trenutno raspolo\u017eenje (npr. sretan, tu\u017ean, opu\u0161ten), nakon \u010dega im aplikacija prikazuje odgovaraju\u0107e filmske preporuke. Aplikacija mo\u017ee koristiti stati\u010dki set podataka ili biti pro\u0161irena da koristi eksterni API (npr. TMDB API).</p> <p>Ovaj projekat je kreiran kao edukativni primjer za radionicu i slu\u017ei kao osnova za u\u010denje rada sa React komponentama, stilizacijom i prikazom dinami\u010dkog sadr\u017eaja.</p>"},{"location":"content/react-project/#tehnologije-koje-se-koriste","title":"Tehnologije koje se koriste","text":"<p>Moodflix je izgra\u0111en kori\u0161tenjem modernog React ekosistema i alata za razvoj brzih i responsivnih web aplikacija. U nastavku su navedene klju\u010dne tehnologije kori\u0161tene u ovom projektu:</p>"},{"location":"content/react-project/#frontend","title":"\ud83c\udfaf Frontend","text":"<ul> <li>React (<code>v18.3.1</code>) \u2013 JavaScript biblioteka za izgradnju korisni\u010dkih interfejsa.</li> <li>React Router DOM (<code>v6.26.2</code>) \u2013 Za upravljanje rutama i navigacijom unutar aplikacije.</li> <li>Tailwind CSS (<code>v3.4.13</code>) \u2013 Utility-first CSS framework za brzo i elegantno stilizovanje korisni\u010dkog interfejsa.</li> <li>PropTypes (<code>v15.8.1</code>) \u2013 Za tipizaciju props-a u komponentama.</li> </ul>"},{"location":"content/react-project/#razvoj-i-build-alati","title":"\ud83d\ude80 Razvoj i build alati","text":"<ul> <li>Vite (<code>v5.4.8</code>) \u2013 Ultra brzi build alat i dev server.</li> <li>ESLint (<code>v9.11.1</code>) \u2013 Alat za stati\u010dku analizu koda i osiguranje konzistentnog stila koda.</li> <li>PostCSS + Autoprefixer \u2013 Za automatsku kompatibilnost CSS koda sa razli\u010ditim browserima.</li> </ul>"},{"location":"content/react-project/#ostalo","title":"\ud83d\udce6 Ostalo","text":"<ul> <li>lucide-react (<code>v0.445.0</code>) \u2013 Ikonice kori\u0161tene za UI.</li> </ul> <p>Projekat koristi ES module sistem (<code>\"type\": \"module\"</code>) i organizovan je kao Vite aplikacija sa <code>dev</code>, <code>build</code> i <code>preview</code> skriptama.</p>"},{"location":"content/react-project/#struktura-projekta","title":"Struktura projekta","text":"<p>Ispod se nalazi prikaz direktorijske strukture aplikacije Moodflix sa kratkim opisom svakog direktorija i fajla.</p> <p>moodflix/ \u251c\u2500\u2500 public/ # Javne datoteke (favicon, index.html, itd.) \u251c\u2500\u2500 src/ # Glavni izvorni kod aplikacije \u2502 \u251c\u2500\u2500 assets/ # Slike, ikone i drugi medijski fajlovi \u2502 \u2502 \u2514\u2500\u2500 react.svg \u2502 \u251c\u2500\u2500 common/ # Zajedni\u010dke varijable i konstante \u2502 \u2502 \u2514\u2500\u2500 constants.js \u2502 \u251c\u2500\u2500 components/ # Reusable komponente po sekcijama \u2502 \u2502 \u251c\u2500\u2500 Footer/ \u2502 \u2502 \u2502 \u2514\u2500\u2500 Footer.jsx \u2502 \u2502 \u251c\u2500\u2500 Hero/ \u2502 \u2502 \u2502 \u2514\u2500\u2500 Hero.jsx \u2502 \u2502 \u251c\u2500\u2500 Movie/ \u2502 \u2502 \u2502 \u251c\u2500\u2500 Movie.jsx \u2502 \u2502 \u2502 \u2514\u2500\u2500 MovieList.jsx \u2502 \u2502 \u2514\u2500\u2500 Navbar/ \u2502 \u2502 \u2514\u2500\u2500 Navbar.jsx \u2502 \u251c\u2500\u2500 pages/ # Glavne stranice aplikacije \u2502 \u2502 \u251c\u2500\u2500 Home.jsx \u2502 \u2502 \u2514\u2500\u2500 MovieList.jsx \u2502 \u251c\u2500\u2500 App.jsx # Root komponenta aplikacije \u2502 \u251c\u2500\u2500 main.jsx # Ulazna ta\u010dka aplikacije \u2502 \u2514\u2500\u2500 index.css # Globalni CSS \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 index.html # Glavni HTML fajl \u251c\u2500\u2500 package.json # Konfiguracija paketa i zavisnosti \u251c\u2500\u2500 postcss.config.js \u251c\u2500\u2500 tailwind.config.js # Tailwind konfiguracija \u251c\u2500\u2500 vite.config.js # Vite konfiguracija \u2514\u2500\u2500 README.md</p> <p>Ova struktura omogu\u0107ava jednostavno upravljanje komponentama i pro\u0161irivanje aplikacije po potrebi. Svaka sekcija (npr. <code>Movie</code>, <code>Navbar</code>) ima svoju mapu za bolje razdvajanje logike i stilova.</p>"},{"location":"content/react-project/#funkcionalnosti-aplikacije","title":"Funkcionalnosti aplikacije","text":"<p>Aplikacija Moodflix omogu\u0107ava korisnicima da dobiju preporuke za filmove na osnovu svog trenutnog raspolo\u017eenja. Fokus je na jednostavnom korisni\u010dkom iskustvu i osnovnim principima React razvoja.</p>"},{"location":"content/react-project/#1-odabir-raspolozenja","title":"\ud83c\udfad 1. Odabir raspolo\u017eenja","text":"<ul> <li>Na po\u010detnoj stranici korisnik bira jedno od ponu\u0111enih raspolo\u017eenja:</li> <li>\ud83d\ude0a Happy</li> <li>\ud83d\ude22 Sad</li> <li>\ud83d\ude0e Excited</li> <li>\ud83d\ude0c Relaxed</li> <li>\ud83d\ude20 Angry</li> <li>\ud83e\udd14 Thoughtful</li> <li>Svako dugme poziva funkciju koja postavlja trenutno stanje (<code>mood</code>) u aplikaciji.</li> </ul>"},{"location":"content/react-project/#2-prikaz-preporucenih-filmova","title":"\ud83c\udfac 2. Prikaz preporu\u010denih filmova","text":"<ul> <li>Na osnovu odabranog raspolo\u017eenja, aplikacija prikazuje listu relevantnih filmova.</li> <li>Filmovi su prikazani sa:</li> <li>Naslovnicom (poster)</li> <li>Nazivom filma</li> <li>Podaci mogu biti:</li> <li>Predefinisani u aplikaciji (<code>constants.js</code>)</li> <li>Ili dohva\u0107eni iz vanjskog API-ja (npr. TMDB API)</li> </ul>"},{"location":"content/react-project/#3-promjena-raspolozenja","title":"\ud83d\udd04 3. Promjena raspolo\u017eenja","text":"<ul> <li>Korisnik mo\u017ee kliknuti na dugme <code>Change Mood</code> u navigaciji kako bi se vratio na po\u010detni ekran i izabrao novo raspolo\u017eenje.</li> </ul>"},{"location":"content/react-project/#ostale-funkcionalnosti","title":"\u2705 Ostale funkcionalnosti","text":"<ul> <li>Navigacija kroz komponente putem React Router-a</li> <li>Reaktivan interfejs sa Tailwind CSS</li> <li>Modularna struktura i organizacija komponenti</li> </ul>"},{"location":"content/react-project/#glavne-komponente-i-objasnjenja","title":"Glavne komponente i obja\u0161njenja","text":"<p>U nastavku su obja\u0161njene klju\u010dne React komponente koje \u010dine aplikaciju Moodflix. Svaka komponenta ima jasno definisanu odgovornost u okviru UI/UX-a.</p>"},{"location":"content/react-project/#herojsx","title":"\ud83e\udde0 <code>Hero.jsx</code>","text":"<ul> <li>Prikazuje glavni ekran za odabir raspolo\u017eenja.</li> <li>Sadr\u017ei dugmad za svako dostupno raspolo\u017eenje.</li> <li>Kada se klikne na dugme, stanje <code>mood</code> se postavlja u aplikaciji i korisnik se preusmjerava na listu filmova.</li> </ul>"},{"location":"content/react-project/#moviejsx","title":"\ud83c\udfac <code>Movie.jsx</code>","text":"<ul> <li>Predstavlja jednu filmsku karticu.</li> <li>Prikazuje naslovnicu/poster i naziv filma.</li> <li>Koristi se unutar <code>MovieList.jsx</code> za prikaz vi\u0161e filmova.</li> </ul>"},{"location":"content/react-project/#movielistjsx","title":"\ud83c\udf9e\ufe0f <code>MovieList.jsx</code>","text":"<ul> <li>Prikazuje listu svih filmova za izabrano raspolo\u017eenje.</li> <li>Prikuplja podatke iz <code>constants.js</code> (ili iz API-ja ako se koristi).</li> <li>Koristi <code>.map()</code> da renderuje vi\u0161e <code>Movie</code> komponenti.</li> </ul>"},{"location":"content/react-project/#navbarjsx","title":"\ud83e\udded <code>Navbar.jsx</code>","text":"<ul> <li>Prikazuje vrh stranice sa nazivom aplikacije i linkom za povratak na po\u010detni ekran (\"Change Mood\").</li> <li>Koristi <code>Link</code> iz <code>react-router-dom</code> za navigaciju.</li> </ul>"},{"location":"content/react-project/#homejsx","title":"\ud83c\udfe0 <code>Home.jsx</code>","text":"<ul> <li>Glavna po\u010detna stranica aplikacije.</li> <li>Sadr\u017ei <code>Hero</code> komponentu i logiku za postavljanje raspolo\u017eenja.</li> </ul>"},{"location":"content/react-project/#appjsx","title":"\ud83d\udcc4 <code>App.jsx</code>","text":"<ul> <li>Root komponenta aplikacije.</li> <li>Sadr\u017ei <code>BrowserRouter</code> i defini\u0161e sve rute (<code>/</code>, <code>/movies</code>).</li> <li>Omogu\u0107ava prikaz razli\u010ditih stranica na osnovu URL-a.</li> </ul>"},{"location":"content/react-project/#constantsjs","title":"\ud83d\udcc4 <code>constants.js</code>","text":"<ul> <li>Sadr\u017ei stati\u010dke podatke o filmovima grupisane po raspolo\u017eenju.</li> <li>Na primjer:</li> </ul> <pre><code>export const moviesByMood = {\n  happy: [...],\n  sad: [...],\n  // itd.\n};\n\n## \ud83d\udd27 Mogu\u0107a pobolj\u0161anja (Future improvements)\n\nMoodflix je zami\u0161ljen kao jednostavna edukativna aplikacija, ali postoji mnogo prostora za dodatne funkcionalnosti i pro\u0161irenja. U nastavku su predlo\u017eena mogu\u0107a pobolj\u0161anja koja bi unaprijedila korisni\u010dko iskustvo i funkcionalnost aplikacije.\n\n### \ud83c\udf10 1. Integracija sa TMDB API\n- Umjesto stati\u010dkih podataka, koristiti pravi **TMDB API** za dohvat filmova prema \u017eanru, raspolo\u017eenju ili popularnosti.\n- Omogu\u0107iti prikaz dodatnih informacija kao \u0161to su opis filma, ocjena, datum izlaska itd.\n\n### \ud83d\udcf1 2. Responsive dizajn i mobilna optimizacija\n- Podesiti aplikaciju da izgleda odli\u010dno i na mobilnim ure\u0111ajima koriste\u0107i Tailwind breakpoint-e.\n\n### \ud83c\udfad 3. Vi\u0161e raspolo\u017eenja i prilagodba korisniku\n- Dodati dodatna raspolo\u017eenja ili omogu\u0107iti korisniku da unese vlastito raspolo\u017eenje.\n- Na osnovu toga prikazivati filmove koriste\u0107i sentiment analizu ili NLP.\n\n### \ud83d\udcc4 4. Detaljna stranica filma\n- Omogu\u0107iti klik na film koji vodi na posebnu stranicu sa detaljima o filmu (sinopsis, trailer, gluma\u010dka postava itd.).\n\n### \ud83d\udcbe 5. \u010cuvanje historije i favorita\n- Dodati mogu\u0107nost da korisnik sa\u010duva omiljene filmove.\n- Implementirati LocalStorage ili backend za pohranu istorije gledanja i preferencija.\n\n### \ud83c\udfa8 6. Animacije i interaktivnost\n- Dodati lagane animacije pri prelasku izme\u0111u raspolo\u017eenja i u\u010ditavanja filmova za bolje korisni\u010dko iskustvo.\n\n## \u2705 Zaklju\u010dak\n\nMoodflix je jednostavna, ali efektna React aplikacija koja demonstrira kako frontend logika mo\u017ee biti povezana s korisni\u010dkim emocijama da bi se kreiralo korisni\u010dko iskustvo.\n\nKroz ovaj projekat obra\u0111ene su osnovne teme razvoja modernih web aplikacija:\n- upravljanje stanjima i navigacijom pomo\u0107u React-a,\n- modularna organizacija komponenti,\n- osnovna upotreba eksternih podataka (stati\u010dkih ili API),\n- i stilizacija koriste\u0107i Tailwind CSS.\n\nOvaj projekat mo\u017ee poslu\u017eiti kao osnova za slo\u017eenije aplikacije koje uklju\u010duju rad s API-jem, korisni\u010dke sesije, autentifikaciju, i naprednu logiku preporuka.\n\n&gt; Moodflix nije samo tehni\u010dki demo, ve\u0107 i prilika da se razumije kako male ideje mogu imati velik edukativni potencijal.\n\n---\n\n\ud83d\udcc1 **Repozitorij**: [https://github.com/kaizerpwn/moodflix]\n</code></pre>"},{"location":"content/restful-api/","title":"APIs and RESTful services","text":""},{"location":"content/restful-api/#uvod","title":"Uvod","text":"<p>RESTful API-ji su klju\u010dna komponenta u modernom web razvoju. Oni omogu\u0107avaju komunikaciju izme\u0111u razli\u010ditih aplikacija putem interneta. REST (\u0161to je skra\u0107enica za Representational State Transfer) API-ji funkcioni\u0161u na bestatusnoj klijent-server arhitekturi, pru\u017eaju\u0107i standardizovan na\u010din za kreiranje, \u010ditanje, a\u017euriranje i brisanje resursa. Integracija RESTful API-ja sa Reactom unapre\u0111uje funkcionalnost va\u0161ih web aplikacija omogu\u0107avaju\u0107i im da dinami\u010dki dohva\u0107aju i a\u017euriraju podatke. Ova integracija olak\u0161ava besprijekorno korisni\u010dko iskustvo, osiguravaju\u0107i da aplikacija ostane responzivna i a\u017eurna. U ovom dijelu \u0107emo se posvetiti osnovama RESTful API-ja i provesti vas kroz proces rada s njima u Reactu. Od postavljanja novog React projekta do rukovanja CRUD operacijama i implementacije autentifikacije, ste\u0107i \u0107ete sveobuhvatno razumijevanje integracije API-ja u va\u0161e React aplikacije.</p>"},{"location":"content/restful-api/#razumijevanje-restful-api-ja","title":"Razumijevanje RESTful API-ja","text":""},{"location":"content/restful-api/#sta-je-rest","title":"\u0160ta je REST?","text":"<p>REST (Representational State Transfer) je arhitektonski stil koji defini\u0161e skup ograni\u010denja koja se koriste prilikom kreiranja web servisa. To nije protokol, ve\u0107 skup principa koji diktiraju kako bi se web servisi trebali pona\u0161ati. U svojoj sr\u017ei, REST se oslanja na bestatusni klijent-server komunikacijski model, \u0161to zna\u010di da svaki zahtjev od klijenta sadr\u017ei sve informacije potrebne za razumijevanje i obradu tog zahtjeva.</p>"},{"location":"content/restful-api/#kljucni-principi-rest-a","title":"Klju\u010dni principi REST-a","text":"<p>RESTful API-ji slijede nekoliko klju\u010dnih principa, uklju\u010duju\u0107i bestatusnost, uniformni interfejs i interakcije zasnovane na resursima. Bestatusnost osigurava da je svaki zahtjev od klijenta prema serveru nezavisan i da server ne pohranjuje nikakve informacije o stanju klijenta izme\u0111u zahtjeva. Princip uniformnog interfejsa defini\u0161e standardizovan na\u010din interakcije s resursima, promovi\u0161u\u0107i jednostavnost i dosljednost.</p>"},{"location":"content/restful-api/#anatomija-restful-api-ja","title":"Anatomija RESTful API-ja","text":"<p>RESTful API se sastoji od resursa, od kojih je svaki identifikovan jedinstvenim URI-jem (Uniform Resource Identifier). Ovi resursi se mogu manipulisati koriste\u0107i standardne HTTP metode kao \u0161to su GET, POST, PUT, PATCH i DELETE. Odgovori API-ja obi\u010dno uklju\u010duju podatke u formatu kao \u0161to je JSON (JavaScript Object Notation) ili XML (eXtensible Markup Language).</p>"},{"location":"content/restful-api/#krajnje-tacke-restful-api-ja","title":"Krajnje ta\u010dke RESTful API-ja","text":"<p>Krajnje ta\u010dke su specifi\u010dni URL-ovi koji predstavljaju resurse koje izla\u017ee RESTful API. Na primjer, jednostavan blog API mogao bi imati krajnje ta\u010dke poput <code>/posts</code> za dohva\u0107anje svih blog objava i <code>/posts/{id}</code> za dohva\u0107anje specifi\u010dne objave prema njenom jedinstvenom identifikatoru. Razumijevanje ovih krajnjih ta\u010daka je klju\u010dno prilikom rada s RESTful API-jima u Reactu, jer one defini\u0161u podatke kojima mo\u017eete pristupiti i manipulisati.</p>"},{"location":"content/restful-api/#kako-uputiti-api-zahtjeve-u-react-u","title":"Kako uputiti API zahtjeve u React-u","text":""},{"location":"content/restful-api/#fetch-api","title":"Fetch API","text":"<p>Fetch API je moderni interfejs za upu\u0107ivanje HTTP zahtjeva u pregledniku. Pru\u017ea mo\u0107niji i fleksibilniji na\u010din rukovanja mre\u017enim zahtjevima u pore\u0111enju sa starijim tehnikama poput XMLHttpRequest.</p> <pre><code>// src/components/ApiExample.js\nimport React, { useState, useEffect } from 'react';\n\nconst ApiExample = () =&gt; {\n  const [data, setData] = useState([]);\n\n  useEffect(() =&gt; {\n    const fetchData = async () =&gt; {\n      try {\n        const response = await fetch('https://api.example.com/posts');\n        const result = await response.json();\n        setData(result);\n      } catch (error) {\n        console.error('Error fetching data:', error);\n      }\n    };\n    fetchData();\n  }, []);\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;API Data&lt;/h1&gt;\n      &lt;ul&gt;\n        {data.map((item) =&gt; (\n          &lt;li key={item.id}&gt;{item.title}&lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default ApiExample;\n</code></pre> <p>U ovom primjeru, <code>useEffect</code> hook se koristi za dohva\u0107anje podataka kada se komponenta montira. Funkcija fetch se koristi za upu\u0107ivanje GET zahtjeva na specificiranu API krajnju ta\u010dku ('https://api.example.com/posts'), a odgovor se konvertuje u JSON koriste\u0107i <code>response.json()</code>.</p>"},{"location":"content/restful-api/#slanje-get-zahtjeva","title":"Slanje GET zahtjeva","text":"<p>Prilikom rada s RESTful API-jima, GET zahtjevi su naj\u010de\u0161\u0107i. Oni dohva\u0107aju podatke sa servera bez da ih mijenjaju. Hajde da pobolj\u0161amo na\u0161 primjer tako da uklju\u010di upitne parametre i obradi razli\u010dite aspekte GET zahtjeva.</p> <p><pre><code>// src/components/ApiExample.js\n\n// ... (previous imports)\n\nconst ApiExample = () =&gt; {\n  const [data, setData] = useState([]);\n  const [loading, setLoading] = useState\n\n(true);\n\n  useEffect(() =&gt; {\n    const fetchData = async () =&gt; {\n      try {\n        // Simulating a delay to show loading state\n        setTimeout(async () =&gt; {\n          const response = await fetch('https://api.example.com/posts?userId=1');\n          const result = await response.json();\n          setData(result);\n          setLoading(false);\n        }, 1000);\n      } catch (error) {\n        console.error('Error fetching data:', error);\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n  }, []);\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;API Data&lt;/h1&gt;\n      {loading ? (\n        &lt;p&gt;Loading...&lt;/p&gt;\n      ) : (\n        &lt;ul&gt;\n          {data.map((item) =&gt; (\n            &lt;li key={item.id}&gt;{item.title}&lt;/li&gt;\n          ))}\n        &lt;/ul&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default ApiExample;\n</code></pre> U ovom primjeru, uvodi se stanje u\u010ditavanja kako bi se korisnicima pru\u017eila povratna informacija dok se podaci dohva\u0107aju. Stanje <code>loading</code> se inicijalno postavlja na <code>true</code> i mijenja na <code>false</code> kada se podaci dohvate.</p>"},{"location":"content/restful-api/#rukovanje-asinhronim-operacijama-sa-asyncawait","title":"Rukovanje asinhronim operacijama sa <code>async/await</code>","text":"<p>Upotreba <code>async/await</code> sintakse \u010dini asinhroni kod \u010ditljivijim i lak\u0161im za rad. Omogu\u0107ava vam da pi\u0161ete asinhroni kod koji izgleda i pona\u0161a se sli\u010dno sinhronom kodu.</p> <pre><code>// src/components/ApiExample.js\n\n// ... (previous imports)\n\nconst ApiExample = () =&gt; {\n  const [data, setData] = useState([]);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() =&gt; {\n    const fetchData = async () =&gt; {\n      try {\n        const response = await fetch('https://api.example.com/posts?userId=1');\n        const result = await response.json();\n        setData(result);\n        setLoading(false);\n      } catch (error) {\n        console.error('Error fetching data:', error);\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n  }, []);\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;API Data&lt;/h1&gt;\n      {loading ? (\n        &lt;p&gt;Loading...&lt;/p&gt;\n      ) : (\n        &lt;ul&gt;\n          {data.map((item) =&gt; (\n            &lt;li key={item.id}&gt;{item.title}&lt;/li&gt;\n          ))}\n        &lt;/ul&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default ApiExample;\n</code></pre> <p>Ovdje je funkcija <code>fetchData</code> deklarisana kao asinhrona funkcija koriste\u0107i klju\u010dnu rije\u010d <code>async</code>. Ovo omogu\u0107ava upotrebu <code>await</code> unutar funkcije, \u010dine\u0107i asinhroni kod jednostavnijim i odr\u017eavaju\u0107i \u010distu i \u010ditljivu strukturu.</p>"},{"location":"content/restful-api/#obrada-gresaka","title":"Obrada gre\u0161aka","text":"<p>Klju\u010dno je elegantno obraditi gre\u0161ke prilikom slanja API zahtjeva. U prethodnim primjerima, uveli smo osnovni mehanizam za obradu gre\u0161aka koriste\u0107i <code>try/catch</code> blokove. Pro\u0161irimo ovo kako bismo pru\u017eili detaljnije poruke o gre\u0161kama.</p> <pre><code>// src/components/ApiExample.js\n\n// ... (previous imports)\n\nconst ApiExample = () =&gt; {\n  const [data, setData] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() =&gt; {\n    const fetchData = async () =&gt; {\n      try {\n        const response = await fetch('https://api.example.com/posts?userId=1');\n\n        if (!response.ok) {\n          throw new Error(`HTTP error! Status: ${response.status}`);\n        }\n\n        const result = await response.json();\n        setData(result);\n        setLoading(false);\n      } catch (error) {\n        console.error('Error fetching data:', error);\n        setError('An error occurred while fetching the data. Please try again later.');\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n  }, []);\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;API Data&lt;/h1&gt;\n      {loading ? (\n        &lt;p&gt;Loading...&lt;/p&gt;\n      ) : error ? (\n        &lt;p&gt;{error}&lt;/p&gt;\n      ) : (\n        &lt;ul&gt;\n          {data.map((item) =&gt; (\n            &lt;li key={item.id}&gt;{item.title}&lt;/li&gt;\n          ))}\n        &lt;/ul&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default ApiExample;\n</code></pre> <p>U ovom primjeru, provjerava se svojstvo <code>response.ok</code> kako bi se utvrdilo da li je HTTP zahtjev bio uspje\u0161an. Ako nije, baca se gre\u0161ka s informacijama o HTTP statusu. Dodatno, postavlja se korisniku prikladnija poruka o gre\u0161ci u stanju <code>error</code> i ona se prikazuje u komponenti.</p>"},{"location":"content/restful-api/#kako-prikazati-api-podatke-u-react-komponentama","title":"Kako prikazati API podatke u React komponentama","text":""},{"location":"content/restful-api/#stanje-i-propertiji-props-u-react-u","title":"Stanje i propertiji (props) u React-u","text":"<p>U Reactu, komponente upravljaju svojim unutra\u0161njim stanjem, \u0161to im omogu\u0107ava da se dinami\u010dki a\u017euriraju i ponovo renderuju na osnovu promjena. Properti (props), s druge strane, se koriste za proslje\u0111ivanje podataka od roditeljskih ka dje\u010dijim komponentama. Hajde da razumijemo kako koristiti stanje i propertije za prikaz API podataka. <pre><code>import React, { useState, useEffect } from 'react';\nimport axios from 'axios';\n\nconst DisplayData = () =&gt; {\n  const [apiData, setApiData] = useState(null);\n\n  useEffect(() =&gt; {\n    const fetchData = async () =&gt; {\n      try {\n        const response = await axios.get('https://api.example.com/data');\n        setApiData(response.data);\n      } catch (error) {\n        console.error('Error fetching data:', error);\n      }\n    };\n\n    fetchData();\n  }, []);\n\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;API Data Display&lt;/h2&gt;\n      {apiData ? (\n        // Render your component using the fetched data\n        &lt;MyComponent data={apiData} /&gt;\n      ) : (\n        // Render a loading state or placeholder\n        &lt;p&gt;Loading...&lt;/p&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nconst MyComponent = ({ data }) =&gt; {\n  return (\n    &lt;div&gt;\n      &lt;p&gt;{data.message}&lt;/p&gt;\n      {/* Render other components based on data */}\n    &lt;/div&gt;\n  );\n};\n\nexport default DisplayData;\n</code></pre></p>"},{"location":"content/restful-api/#azuriranje-stanja-sa-preuzetim-podacima","title":"A\u017euriranje stanja sa preuzetim podacima","text":"<p>Kada se podaci uspje\u0161no preuzmu sa API-ja, mi a\u017euriramo stanje komponente koriste\u0107i <code>setApiData(response.data)</code>. Ovo pokre\u0107e ponovno renderovanje, osiguravaju\u0107i da korisni\u010dko su\u010delje odra\u017eava najnovije informacije.</p>"},{"location":"content/restful-api/#dinamicko-renderovanje-podataka","title":"Dinami\u010dko renderovanje podataka","text":"<p>Proslje\u0111ivanje podataka kao propertija (props) omogu\u0107ava komponentama da dinami\u010dki renderuju sadr\u017eaj. U primjeru, <code>MyComponent</code> prima podatke kao prop i renderuje sadr\u017eaj na osnovu tih podataka.</p>"},{"location":"content/restful-api/#stanja-ucitavanja-i-obrada-gresaka","title":"Stanja u\u010ditavanja i obrada gre\u0161aka","text":"<p>Prikazivanje stanja u\u010ditavanja (<code>&lt;p&gt;U\u010ditavanje...&lt;/p&gt;</code>) dok se \u010deka na API podatke osigurava bolje korisni\u010dko iskustvo. Dodatno, uklju\u010dili smo obradu gre\u0161aka kako bismo uhvatili i zabilje\u017eili sve probleme koji mogu nastati tokom API zahtjeva.</p>"},{"location":"content/restful-api/#crud-operacije-sa-restful-api-jima","title":"CRUD operacije sa RESTful API-jima","text":""},{"location":"content/restful-api/#kreiranje-podataka-post-zahtjevi","title":"Kreiranje podataka (POST zahtjevi)","text":"<p>Kreiranje podataka uklju\u010duje slanje POST zahtjeva API-ju. Implementirajmo jednostavnu formu za dodavanje novih stavki.</p> <p><pre><code>import React, { useState } from 'react';\nimport axios from 'axios';\n\nconst CreateData = () =&gt; {\n  const [newData, setNewData] = useState('');\n\n  const handleCreate = async () =&gt; {\n    try {\n      await axios.post('https://api.example.com/data', { newData });\n      alert('Data created successfully!');\n      // Optionally, fetch and update the displayed data\n    } catch (error) {\n      console.error('Error creating data:', error);\n    }\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Create New Data&lt;/h2&gt;\n      &lt;input\n        type=\"text\"\n        value={newData}\n        onChange={(e) =&gt; setNewData(e.target.value)}\n      /&gt;\n      &lt;button onClick={handleCreate}&gt;Create&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default CreateData;\n</code></pre> U ovom primjeru, hvatamo korisni\u010dki unos pomo\u0107u <code>useState</code> hooka i \u0161aljemo POST zahtjev API-ju kada se klikne na dugme \"Kreiraj\".</p>"},{"location":"content/restful-api/#citanje-podataka-get-zahtjevi","title":"\u010citanje podataka (GET zahtjevi)","text":"<p>\u010citanje podataka uklju\u010duje slanje GET zahtjeva za dohva\u0107anje informacija sa API-ja. Ovo smo ve\u0107 obradili u prethodnom odjeljku o prikazivanju API podataka.</p>"},{"location":"content/restful-api/#azuriranje-podataka-putpatch-zahtjevi","title":"A\u017euriranje podataka (PUT/PATCH zahtjevi)","text":"<p>A\u017euriranje podataka zahtijeva slanje PUT ili PATCH zahtjeva API-ju sa izmijenjenim podacima. Kreirajmo primjer za a\u017euriranje postoje\u0107ih podataka.</p> <pre><code>import React, { useState } from 'react';\nimport axios from 'axios';\n\nconst UpdateData = () =&gt; {\n  const [updatedData, setUpdatedData] = useState('');\n\n  const handleUpdate = async () =&gt; {\n    try {\n      await axios.put('https://api.example.com/data/1', { updatedData });\n      alert('Data updated successfully!');\n      // Optionally, fetch and update the displayed data\n    } catch (error) {\n      console.error('Error updating data:', error);\n    }\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Update Data&lt;/h2&gt;\n      &lt;input\n        type=\"text\"\n        value={updatedData}\n        onChange={(e) =&gt; setUpdatedData(e.target.value)}\n      /&gt;\n      &lt;button onClick={handleUpdate}&gt;Update&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default UpdateData;\n</code></pre> <p>U ovom primjeru, hvatamo a\u017eurirane podatke i \u0161aljemo PUT zahtjev na API krajnju ta\u010dku za specifi\u010dnu stavku.</p>"},{"location":"content/restful-api/#brisanje-podataka-delete-zahtjevi","title":"Brisanje podataka (DELETE zahtjevi)","text":"<p>Brisanje podataka uklju\u010duje slanje DELETE zahtjeva API-ju. Evo primjera kako implementirati funkcionalnost brisanja.</p> <pre><code>import React from 'react';\nimport axios from 'axios';\n\nconst DeleteData = () =&gt; {\n  const handleDelete = async () =&gt; {\n    try {\n      await axios.delete('https://api.example.com/data/1');\n      alert('Data deleted successfully!');\n      // Optionally, fetch and update the displayed data\n    } catch (error) {\n      console.error('Error deleting data:', error);\n    }\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Delete Data&lt;/h2&gt;\n      &lt;button onClick={handleDelete}&gt;Delete&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default DeleteData;\n</code></pre> <p>U ovom primjeru, klik na dugme \"Izbri\u0161i\" pokre\u0107e DELETE zahtjev prema API-ju, uklanjaju\u0107i specificiranu stavku.</p>"},{"location":"content/restful-api/#kako-rukovati-formama-i-korisnickim-unosom","title":"Kako rukovati formama i korisni\u010dkim unosom?","text":""},{"location":"content/restful-api/#kontrolisane-komponente","title":"Kontrolisane komponente","text":"<p>Reactove kontrolisane komponente omogu\u0107avaju nam da dinami\u010dki rukujemo unosom u forme. Vrijednost unosa je kontrolisana stanjem komponente.</p> <pre><code>import React, { useState } from 'react';\n\nconst ControlledComponent = () =&gt; {\n  const [inputValue, setInputValue] = useState('');\n\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Controlled Component&lt;/h2&gt;\n      &lt;input\n        type=\"text\"\n        value={inputValue}\n        onChange={(e) =&gt; setInputValue(e.target.value)}\n      /&gt;\n      &lt;p&gt;Input Value: {inputValue}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default ControlledComponent;\n</code></pre>"},{"location":"content/restful-api/#podnosenje-forme-i-rukovanje-njime","title":"Podno\u0161enje forme i rukovanje njime","text":"<p>Forme u Reactu mogu se podnijeti rukovanjem <code>onSubmit</code> eventom. Kreirajmo jednostavan primjer podno\u0161enja forme.</p> <pre><code>import React, { useState } from 'react';\n\nconst FormSubmission = () =&gt; {\n  const [formData, setFormData] = useState({\n    username: '',\n    password: '',\n  });\n\n  const handleInputChange = (e) =&gt; {\n    setFormData({\n      ...formData,\n      [e.target.name]: e.target.value,\n    });\n  };\n\n  const handleSubmit = (e) =&gt; {\n    e.preventDefault();\n    // Perform form submission logic, e.g., send data to API\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Form Submission&lt;/h2&gt;\n      &lt;form onSubmit={handleSubmit}&gt;\n        &lt;label&gt;\n          Username:\n          &lt;input\n            type=\"text\"\n            name=\"username\"\n            value={formData.username}\n            onChange={handleInputChange}\n          /&gt;\n        &lt;/label&gt;\n        &lt;label&gt;\n          Password:\n          &lt;input\n            type=\"\n\npassword\"\n            name=\"password\"\n            value={formData.password}\n            onChange={handleInputChange}\n          /&gt;\n        &lt;/label&gt;\n        &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n      &lt;/form&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default FormSubmission;\n</code></pre> <p>U ovom primjeru, funkcija <code>handleInputChange</code> a\u017eurira podatke forme u stanju komponente, a funkcija <code>handleSubmit</code> sprje\u010dava podrazumijevano podno\u0161enje forme i omogu\u0107ava vam da izvr\u0161ite prilago\u0111enu logiku, kao \u0161to je slanje podataka API-ju.</p>"},{"location":"content/restful-api/#slanje-podataka-api-ju","title":"Slanje podataka API-ju","text":"<p>Da biste poslali podatke API-ju, integri\u0161ite logiku podno\u0161enja forme sa va\u0161im kodom za HTTP zahtjeve. Koristite odgovaraju\u0107u HTTP metodu (na primjer, POST) za kreiranje novih podataka.</p>"},{"location":"content/restful-api/#validacija-i-poruke-o-greskama","title":"Validacija i poruke o gre\u0161kama","text":"<p>Implementacija validacije forme je klju\u010dna za osiguravanje integriteta podataka. Mo\u017eete koristiti uslovno renderovanje za prikazivanje poruka o gre\u0161kama na osnovu pravila validacije.</p> <pre><code>import React, { useState } from 'react';\n\nconst FormValidation = () =&gt; {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const [error, setError] = useState('');\n\n  const handleSubmit = (e) =&gt; {\n    e.preventDefault();\n\n    if (!username || !password) {\n      setError('Username and password are required.');\n      return;\n    }\n\n    // Perform form submission logic, e.g., send data to API\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Form Validation&lt;/h2&gt;\n      {error &amp;&amp; &lt;p style={{ color: 'red' }}&gt;{error}&lt;/p&gt;}\n      &lt;form onSubmit={handleSubmit}&gt;\n        &lt;label&gt;\n          Username:\n          &lt;input\n            type=\"text\"\n            value={username}\n            onChange={(e) =&gt; setUsername(e.target.value)}\n          /&gt;\n        &lt;/label&gt;\n        &lt;label&gt;\n          Password:\n          &lt;input\n            type=\"password\"\n            value={password}\n            onChange={(e) =&gt; setPassword(e.target.value)}\n          /&gt;\n        &lt;/label&gt;\n        &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n      &lt;/form&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default FormValidation;\n</code></pre> <p>U ovom primjeru, stanje <code>error</code> se koristi za prikazivanje poruke o gre\u0161ci kada validacija forme ne uspije.</p>"},{"location":"content/restful-api/#autentifikacija-i-autorizacija","title":"Autentifikacija i autorizacija","text":""},{"location":"content/restful-api/#razumijevanje-razlike-izmeu-autentifikacije-i-autorizacije","title":"Razumijevanje razlike izme\u0111u autentifikacije i autorizacije","text":"<p>Autentifikacija provjerava identitet korisnika, dok autorizacija odre\u0111uje koje radnje korisnik smije izvr\u0161iti. Autentifikacija zasnovana na tokenima se obi\u010dno koristi za osiguravanje API-ja.</p>"},{"location":"content/restful-api/#implementacija-autentifikacije-zasnovane-na-tokenima","title":"Implementacija autentifikacije zasnovane na tokenima","text":"<p>Da bi se implementirala autentifikacija zasnovana na tokenima, korisnici se obi\u010dno prijavljuju kako bi dobili pristupni token, koji se zatim \u0161alje sa svakim API zahtjevom za autorizaciju.</p> <pre><code>import React, { useState } from 'react';\nimport axios from 'axios';\n\nconst Authentication = () =&gt; {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  const [token, setToken] = useState('');\n\n  const handleLogin = async () =&gt; {\n    try {\n      const response = await axios.post('https://api.example.com/login', {\n        username,\n        password,\n      });\n\n      setToken(response.data.token);\n      // Save the token securely (e.g., in local storage)\n    } catch (error) {\n      console.error('Login failed:', error);\n    }\n  };\n\n  const handleLogout = () =&gt; {\n    setToken('');\n    // Clear the saved token\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Token-based Authentication&lt;/h2&gt;\n      {token ? (\n        &lt;button onClick={handleLogout}&gt;Logout&lt;/button&gt;\n      ) : (\n        &lt;div&gt;\n          &lt;label&gt;\n            Username:\n            &lt;input\n              type=\"text\"\n              value={username}\n              onChange={(e) =&gt; setUsername(e.target.value)}\n            /&gt;\n          &lt;/label&gt;\n          &lt;label&gt;\n            Password:\n            &lt;input\n              type=\"password\"\n              value={password}\n              onChange={(e) =&gt; setPassword(e.target.value)}\n            /&gt;\n          &lt;/label&gt;\n          &lt;button onClick={handleLogin}&gt;Login&lt;/button&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default Authentication;\n</code></pre> <p>U ovom primjeru, funkcija <code>handleLogin</code> \u0161alje POST zahtjev sa korisni\u010dkim kredencijalima, i nakon uspjeha, pristupni token se pohranjuje u stanju komponente.</p>"},{"location":"content/restful-api/#osiguravanje-api-zahtjeva","title":"Osiguravanje API zahtjeva","text":"<p>Da biste osigurali API zahtjeve, uklju\u010dite pristupni token u zaglavlja zahtjeva. Axios pru\u017ea <code>Authorization</code> zaglavlje u ovu svrhu.</p> <pre><code>const fetchData = async () =&gt; {\n  try {\n    const response = await axios.get('https://api.example.com/data', {\n      headers: {\n        Authorization: `Bearer ${token}`,\n      },\n    });\n    // Handle the response\n  } catch (error) {\n    console.error('Error fetching data:', error);\n  }\n};\n</code></pre> <p>Uklju\u010dite ovo zaglavlje u sve zahtjeve koji zahtijevaju autentifikaciju.</p>"},{"location":"content/restful-api/#kako-optimizirati-performanse","title":"Kako optimizirati performanse?","text":""},{"location":"content/restful-api/#kesiranje-api-odgovora","title":"Ke\u0161iranje API odgovora","text":"<p>Ke\u0161iranje API odgovora mo\u017ee zna\u010dajno pobolj\u0161ati performanse. Pohranite preuzete podatke u varijablu stanja ili globalno rje\u0161enje za upravljanje stanjem kao \u0161to je Redux kako biste izbjegli nepotrebne API pozive.</p> <pre><code>const [cachedData, setCachedData] = useState(null);\n\nconst fetchData = async () =&gt; {\n  try {\n    if (cachedData) {\n      // Use cached data if available\n      return;\n    }\n\n    const response = await axios.get('https://api.example.com/data');\n    setCachedData(response.data);\n    // Handle the response\n  } catch (error) {\n    console.error('Error fetching data:', error);\n  }\n};\n</code></pre>"},{"location":"content/restful-api/#lijeno-ucitavanje-i-peginacija","title":"Lijeno u\u010ditavanje i peginacija","text":"<p>Mo\u017eete implementirati lijeno u\u010ditavanje i paginaciju kako biste optimizirali renderovanje velikih skupova podataka. Dohvatite samo podatke potrebne za trenutni prikaz i u\u010ditajte dodatne podatke dok korisnik skroluje ili navigira.</p>"},{"location":"content/restful-api/#optimizacija-ponovnog-renderovanja-pomocu-reactmemo","title":"Optimizacija ponovnog renderovanja pomo\u0107u React.memo","text":"<p><code>React.memo</code> je komponenta vi\u0161eg reda koja memori\u0161e funkcionalne komponente, sprje\u010davaju\u0107i nepotrebna ponovna renderovanja ako se propertiji (props) komponente nisu promijenile.</p> <p><pre><code>import React, { memo } from 'react';\n\nconst MemoizedComponent = memo(({ data }) =&gt; {\n  return (\n    &lt;div&gt;\n      &lt;p&gt;{data.message}&lt;/p&gt;\n      {/* Render other components based on data */}\n    &lt;/div&gt;\n  );\n});\n\nexport default MemoizedComponent;\n</code></pre> Omotajte komponente sa <code>React.memo</code> kako biste optimizirali performanse renderovanja.</p>"},{"location":"content/restful-api/#kako-testirati-vasu-react-aplikaciju-sa-restful-api-jima","title":"Kako testirati va\u0161u React aplikaciju sa RESTful API-jima?","text":"<p>Testiranje je klju\u010dni dio procesa razvoja, osiguravaju\u0107i da va\u0161a aplikacija radi kako se o\u010dekuje i ostaje robusna \u010dak i dok se razvija. U ovom odjeljku, istra\u017eit \u0107emo razli\u010dite aspekte testiranja u React aplikaciji koja interaguje sa RESTful API-jima.</p>"},{"location":"content/restful-api/#jedinicno-testiranje-komponenti","title":"Jedini\u010dno testiranje komponenti","text":"<p>Jedini\u010dno testiranje je fokusirano na testiranje pojedina\u010dnih jedinica koda u izolaciji. Za React komponente, ovo uklju\u010duje testiranje pona\u0161anja komponente, renderovanja i interakcija. Koristit \u0107emo popularnu biblioteku za testiranje <code>@testing-library/react</code> za na\u0161e primjere.</p> <p>Razmotrimo jednostavnu React komponentu koja dohva\u0107a i prikazuje podatke sa RESTful API-ja:</p> <pre><code>// src/components/UserProfile.js\n\nimport React, { useState, useEffect } from 'react';\nimport axios from 'axios';\n\nconst UserProfile = ({ userId }) =&gt; {\n  const [user, setUser] = useState(null);\n\n  useEffect(() =&gt; {\n    const fetchUser = async () =&gt; {\n      try {\n        const response = await axios.get(`https://api.example.com/users/${userId}`);\n        setUser(response.data);\n      } catch (error) {\n        console.error('Error fetching user data:', error);\n      }\n    };\n\n    fetchUser();\n  }, [userId]);\n\n  return (\n    &lt;div&gt;\n      {user ? (\n        &lt;div&gt;\n          &lt;h2&gt;{user.name}&lt;/h2&gt;\n          &lt;p&gt;Email: {user.email}&lt;/p&gt;\n        &lt;/div&gt;\n      ) : (\n        &lt;p&gt;Loading user data...&lt;/p&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n\nexport default UserProfile;\n</code></pre> <p>Sada, kreirajmo jedini\u010dni test za ovu komponentu:</p> <pre><code>// src/components/UserProfile.test.js\n\nimport React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport UserProfile from './UserProfile';\n\ntest('renders user profile data', async () =&gt; {\n  // Mocking Axios for unit testing\n  jest.mock('axios');\n  import axios from 'axios';\n  axios.get.mockResolvedValue({ data: { name: 'John Doe', email: 'john@example.com' } });\n\n  // Render the component with a mocked userId\n  render(&lt;UserProfile userId={1} /&gt;);\n\n  // Check if the loading state is displayed initially\n  expect(screen.getByText('Loading user data...')).toBeInTheDocument();\n\n  // Wait for the component to render with fetched data\n  const nameElement = await screen.findByText('John Doe');\n  const emailElement = screen.getByText('Email: john@example.com');\n\n  // Check if the user data is displayed correctly\n  expect(nameElement).toBeInTheDocument();\n  expect(emailElement).toBeInTheDocument();\n});\n</code></pre> <p>Ovaj jedini\u010dni test koristi Jest i <code>@testing-library/react</code> kako bi osigurao da UserProfile komponenta ispravno renderuje podatke korisnika. Mi mokiramo Axios biblioteku kako bismo simulirali uspje\u0161an API odgovor. Na ovaj na\u010din, test se fokusira na pona\u0161anje komponente bez stvarnih mre\u017enih zahtjeva.</p>"},{"location":"content/restful-api/#mokiranje-api-zahtjeva-za-testiranje","title":"Mokiranje API zahtjeva za testiranje","text":"<p>Mokiranje API zahtjeva je klju\u010dno za izolovanje komponenti i testiranje njihove logike bez oslanjanja na stvarnu mre\u017enu komunikaciju. U prethodnom primjeru, koristili smo Jestovu funkciju <code>jest.mock</code> za mokiranje Axios biblioteke. Evo jo\u0161 jednog primjera sa slo\u017eenijom komponentom koja \u0161alje vi\u0161e API zahtjeva: <pre><code>// src/components/PostList.js\n\nimport React, { useState, useEffect } from 'react';\nimport axios from 'axios';\n\nconst PostList = () =&gt; {\n  const [posts, setPosts] = useState([]);\n\n  useEffect(() =&gt; {\n    const fetchPosts = async () =&gt; {\n      try {\n        const response = await axios.get('https://api.example.com/posts');\n        setPosts(response.data);\n      } catch (error) {\n        console.error('Error fetching posts:', error);\n      }\n    };\n\n    fetchPosts();\n  }, []);\n\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Posts&lt;/h2&gt;\n      &lt;ul&gt;\n        {posts.map((post) =&gt; (\n          &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default PostList;\n</code></pre> Sada, kreirajmo test za ovu komponentu, mokiraju\u0107i API zahtjeve: <pre><code>// src/components/PostList.test.js\n\nimport React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport axios from 'axios';\nimport PostList from './PostList';\n\ntest('renders a list of posts', async () =&gt; {\n  // Mocking Axios for unit testing\n  jest.mock('axios');\n  axios.get.mockResolvedValue({ data: [{ id: 1, title: 'Post 1' }, { id: 2, title: 'Post 2' }] });\n\n  // Render the component\n  render(&lt;PostList /&gt;);\n\n  // Wait for the component to render with fetched data\n  const post1Element = await screen.findByText('Post 1');\n  const post2Element = screen.getByText('Post 2');\n\n  // Check if the posts are displayed correctly\n  expect(post1Element).toBeInTheDocument();\n  expect(post2Element).toBeInTheDocument();\n});\n</code></pre> U ovom testu, mokiramo Axios biblioteku kako bismo simulirali uspje\u0161an API odgovor koji sadr\u017ei niz objava. Test provjerava da li <code>PostList</code> komponenta renderuje o\u010dekivane objave.</p>"},{"location":"content/restful-api/#end-to-end-testiranje-sa-alatima-poput-cypress-a","title":"End-to-End testiranje sa alatima poput Cypress-a","text":"<p>End-to-End (E2E) testiranje osigurava da cijela va\u0161a aplikacija radi besprijekorno, uklju\u010duju\u0107i interakcije izme\u0111u razli\u010ditih komponenti. Cypress je mo\u0107an E2E alat za testiranje web aplikacija, koji pru\u017ea jednostavan API za pisanje testova.</p> <p>Kreirajmo jednostavan Cypress test kako bismo osigurali da na\u0161a React aplikacija ispravno interaguje sa RESTful API-jem:</p> <pre><code>// cypress/integration/api_integration_spec.js\n\ndescribe('API Integration Tests', () =&gt; {\n  it('successfully fetches user data from the API', () =&gt; {\n    cy.intercept('GET', 'https://api.example.com/users/1', { fixture: 'user.json' });\n\n    cy.visit('/user-profile/1');\n\n    cy.get('h2').should('contain.text', 'John Doe');\n    cy.get('p').should('contain.text', 'Email: john@example.com');\n  });\n\n  it('successfully fetches and displays posts from the API', () =&gt; {\n    cy.intercept('GET', 'https://api.example.com/posts', { fixture: 'posts.json' });\n\n    cy.visit('/post-list');\n\n    cy.get('li').should('have.length', 2);\n    cy.get('li').first().should('contain.text', 'Post 1');\n    cy.get('li').last().should('contain.text', 'Post 2');\n  });\n});\n</code></pre> <p>U ovom Cypress testu, koristimo komandu <code>cy.intercept</code> da presretnemo API zahtjeve i odgovorimo sa unaprijed definisanim fajlovima (<code>user.json</code> i <code>posts.json</code>). Test zatim posje\u0107uje razli\u010dite rute aplikacije i provjerava da li se prikazuju o\u010dekivani podaci.</p> <p>Da biste pokrenuli Cypress testove, osigurajte da imate instaliran Cypress: <pre><code>npm install cypress --save-dev\n</code></pre></p> <p>I dodajte skriptu u va\u0161 <code>package.json</code>:</p> <pre><code>\"scripts\": {\n  \"cypress:open\": \"cypress open\"\n}\n</code></pre> <p>Pokrenite Cypress koriste\u0107i:</p> <pre><code>npm run cypress:open\n</code></pre> <p>Ovi end-to-end testovi poma\u017eu da se osigura da cijela va\u0161a aplikacija, uklju\u010duju\u0107i interakcije sa RESTful API-jima, funkcioni\u0161e ispravno.</p>"},{"location":"content/restful-api/#zakljucak","title":"Zaklju\u010dak","text":"<p>Rad sa RESTful API-jima u Reactu otvara svijet mogu\u0107nosti za izgradnju dinami\u010dnih i web aplikacija vo\u0111enih podacima. Od dohva\u0107anja i prikazivanja podataka do rukovanja korisni\u010dkim unosom i autentifikacijom, ovaj vodi\u010d je obuhvatio \u0161irok spektar tema kako bi vam pomogao da postanete vje\u0161ti u integraciji API-ja sa va\u0161im React projektima.</p> <p>Zapamtite da klju\u010d uspje\u0161ne integracije API-ja le\u017ei u razumijevanju principa REST-a, odabiru pravih alata i biblioteka, te pra\u0107enju najboljih praksi za organizaciju koda, obradu gre\u0161aka i sigurnost. Redovno testiranje, kako jedini\u010dno tako i end-to-end testiranje, osigurava pouzdanost i robusnost va\u0161e aplikacije.</p>"}]}